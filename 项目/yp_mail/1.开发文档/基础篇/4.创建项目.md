> 商品服务、仓储服务、订单服务、优惠券服务、用户服务

common

> 1）、web、openfeign
> 2）、每一个服务，包名com.atguigu.gulimall.xxx(product/order/ware/coupon/member)
> 3）、模块名：gulimall-coupon

## SpringCloud Alibaba

#### 1. 简介

> Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过Spring Cloud 编程模型轻松使用这些组件来开发分布
> 式应用服务。
>
> 依托Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。
>
> [https://github.com/alibaba/spring-cloud-alibaba](https://github.com/alibaba/spring-cloud-alibaba)

2. 为什么使用

> eureka停止维护

**SpringCloud 的几大痛点:**
SpringCloud 部分组件停止维护和更新，给开发带来不便；
SpringCloud 部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发和定制
SpringCloud 配置复杂，难以上手，部分配置差别难以区分和合理应用

**SpringCloud Alibaba 的优势：**
阿里使用过的组件经历了考验，性能强悍，设计合理，现在开源出来大家用
成套的产品搭配完善的可视化界面给开发运维带来极大的便利
搭建简单，学习曲线低

**结合SpringCloud Alibaba 我们最终的技术搭配方案：**
SpringCloud Alibaba - Nacos：注册中心（服务发现/注册）
SpringCloud Alibaba - Nacos：配置中心（动态配置管理）
spring-cloud-loadbalancer：负载均衡(Ribbon停止使用)
SpringCloud - Feign：声明式HTTP 客户端（调用远程服务）
SpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）
SpringCloud - Gateway：API 网关（webflux 编程模式）
SpringCloud - Sleuth：调用链监控
SpringCloud Alibaba - Seata：原Fescar，即分布式事务解决方案

### 版本选择

聚合工程pom

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.youpin</groupId>
    <artifactId>youpin-mail</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>youpin-main</name>
    <description>聚合工程</description>

    <packaging>pom</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.3</version>
    </parent>

    <modules>
        <module>renren-fast</module>
        <module>youpin-product</module>
        <module>youpin-member</module>
        <module>youpin-order</module>
        <module>youpin-coupon</module>
        <module>youpin-ware</module>
        <module>renren-fast</module>
        <module>youpin-common</module>
        <module>youpin-feign</module>
        <module>youpin-gateway</module>
    </modules>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencyManagement>
        <dependencies>
            <!--springcloud依赖-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2021.0.1.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--springcloud alibaba依赖-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>2021.0.1</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

</project>
```

### SpringCloud Alibaba-Nacos[作为注册中心]

> Nacos 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。他是使用java 编写。需要依赖java 环境
> Nacos 文档地址： [https://nacos.io/zh-cn/docs/quick-start.html](https://nacos.io/zh-cn/docs/quick-start.html)

1. 下载nacos-server

> [https://github.com/alibaba/nacos/releases](https://github.com/alibaba/nacos/releases)

2. 启动nacos-server

> 双击bin 中的startup.cmd 文件
> 访问[http://localhost:8848/nacos/](http://localhost:8848/nacos/)
> 使用默认的nacos/nacos 进行登录

3. 将微服务注册到nacos 中

```java
<!--nacos注册中心-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    <exclusions>
        <!--排除nacos中的ribbon, 因为spring的openFeign已经不支持ribbon了-->
        <exclusion>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<!--加入spring-cloud-loadbalancer依赖 并且在nacos中排除ribbon依赖，不然loadbalancer无效-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-loadbalancer</artifactId>
</dependency>

<!--  端点监控场景依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

4. 配置文件中Nacos Server 地址

```properties
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

5. @EnableDiscoveryClient 开启服务注册发现功能

```java
@SpringBootApplication
@MapperScan(basePackages = "org.youpin.mapper")
@EnableDiscoveryClient
public class ProductCloud {
    public static void main(String[] args) {
        SpringApplication.run(ProductCloud.class, args);
    }
}
```

6. nacos 服务列表是否已经注册上服务

```properties
# 注意：每一个应用都应该有名字，这样才能注册上去。修改application.properties 文件
spring.application.name=service-provider
server.port=8000
```

## OpenFeign远程调用

- pom依赖

```xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

- 被调用方生命api

```java
@FeignClient("youpin-coupon")
public interface CouponFeignService {
    @RequestMapping("smsCoupon/member/list")
    ServiceResponst getCouponMembers();
}
```

- 调用方

```java
@RestController
@RequestMapping("ums")
public class UmsMemberController {

    @Autowired
    private IUmsMemberService umsMemberService;

    @Autowired
    private CouponFeignService couponFeignService;

    @RequestMapping("coupon")
    public ServiceResponst getMemberCoupon() {
        UmsMember member = new UmsMember();
        member.setNickname("jock");
        return ServiceResponst.ok().put("member", member).put("coupon", couponFeignService.getCouponMembers());
    }
}
```

调用方 配置

```java
@SpringBootApplication
@MapperScan(basePackages = "org.youpin.mapper")
// 开启服务注册中心
@EnableDiscoveryClient
// 开启openFeign的接口扫描
@EnableFeignClients(basePackages = "org.youpin.api")
public class MemberCloud {
    public static void main(String[] args) {
        SpringApplication.run(MemberCloud.class, args);
    }
}
```

- 更过设置

> [https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/na](https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/na)cos-example/nacos-discovery-example/readme-zh.md#more

## Nacos[作为配置中心]

```xml
<!--nacos配置中心-->
<dependency>
  <groupId>com.alibaba.cloud</groupId>
  <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

```yaml
#从配置中心加载配置文件
#文件名是通过公式来拼接${prefix}-${spring.profiles.active}.${file-extension}
spring:
  cloud:
    nacos:
      config:
        server-addr: localhost:8848
        namespace: dev01
        group: DEFAULT_GROUP
        prefix: youpin-product
        file-extension: yml
        # 通用配置
        shared-configs: comom.yml
        refreshable-dataids: comom.yml
  profiles:
    active: dev
```

#### 动态刷新配置

> 应用会从Nacos Config 中获取相应的配置，并添加在Spring Environment的PropertySources 中。这里我们使用@Value 注解来将对应的配置注入到SampleController 的userName 和age 字段，并添加@RefreshScope 打开动态刷新功能

```java
@RefreshScope
class SampleController {
    @Value("${user.name}")
    String userName;
    
    @Value("${user.age}")
    int age;
}
```

## nacos配置中心

### 1. 核心概念

> **命名空间**：
> 用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的Group 或Data ID 的
> 配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生
> 产环境的资源（如配置、服务）隔离等.

> **配置集**：
> 一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配
> 置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级
> 别等配置项.

> **配置集ID:**
> Nacos 中的某个配置集的ID。配置集ID 是组织划分配置的维度之一。Data ID 通常用于组
> 织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有
> 意义的名称标识。Data ID 通常采用类Java 包（如com.taobao.tc.refund.log.level）的命名
> 规则保证全局唯一性。此命名规则非强制。

> **配置分组：**
> Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如Buy 或
> Trade ）对配置集进行分组，从而区分Data ID 相同的配置集。当您在Nacos 上创建一个
> 配置时，如果未填写配置分组的名称，则配置分组的名称默认采用DEFAULT_GROUP 。配置
> 分组的常见场景：不同的应用或组件使用了相同的配置类型，如database_url 配置和
> MQ_topic 配置

### 2. 原理

> **自动注入：**
> NacosConfigStarter 实现了org.springframework.cloud.bootstrap.config.PropertySourceLocator
> 接口，并将优先级设置成了最高。
>
> 在Spring Cloud 应用启动阶段，会主动从Nacos Server 端获取对应的数据，并将获取到的
> 数据转换成PropertySource 且注入到Environment 的PropertySources 属性中，所以使用
> @Value 注解也能直接获取Nacos Server 端配置的内容。

> **动态刷新：**
> Nacos Config Starter 默认为所有获取数据成功的Nacos 的配置项添加了监听功能，在监听
> 到服务端配置发生变化时会实时触发
> org.springframework.cloud.context.refresh.ContextRefresher 的refresh 方法。

> 如果需要对Bean 进行动态刷新，请参照Spring 和Spring Cloud 规范。推荐给类添加
> @RefreshScope 或@ConfigurationProperties 注解

# Sentinel

### 简介

官方文档：[https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D](https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D)
项目地址：[https://github.com/alibaba/Sentinel](https://github.com/alibaba/Sentinel)
随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，
从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。

> **Sentinel 具有以下特征:**
> 丰富的应用场景：Sentinel 承接了阿里巴巴近10 年的双十一大促流量的核心场
> 景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集
> 群流量控制、实时熔断下游不可用应用等。
>
> 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入
> 应用的单台机器秒级数据，甚至500 台以下规模的集群的汇总运行情况。
>
> 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如
> 与Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配
> 置即可快速地接入Sentinel。
>
> 完善的SPI 扩展点：Sentinel 提供简单易用、完善的SPI 扩展接口。您可以通过
> 实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21571611/1652623667676-502862d0-66ea-4514-b09c-055d0899daee.png#clientId=u891ef93a-4d02-4&from=paste&height=457&id=u2187e1cb&name=image.png&originHeight=799&originWidth=1705&originalType=binary&ratio=1&rotation=0&showTitle=false&size=536669&status=done&style=none&taskId=ua0022dca-12fd-493f-9af3-0986cb04aad&title=&width=974.2857142857143)
**Sentinel 分为两个部分:**

- 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有Java 运行时环境，同时对Dubbo / Spring Cloud 等框架也有较好的支持
- 控制台（Dashboard）基于Spring Boot 开发，打包后可以直接运行，不需要额外的Tomcat 等应用容器

**Sentinel 基本概念**

> **资源:**
> 资源是Sentinel 的关键概念。它可以是Java 应用程序中的任何内容，例如，由应用程序提
> 供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文
> 档中，我们都会用资源来描述代码块

> **只要通过Sentinel API 定义的代码，就是资源，能够被Sentinel 保护起来**。大部分情况下，
> 可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。

> **规则:**
> 围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规
> 则。所有规则可以动态实时调整

### Hystrix 与Sentinel 比较

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21571611/1652624256979-0a462c2b-ddb5-4e0e-a4e1-abb201188e34.png#clientId=u891ef93a-4d02-4&from=paste&height=543&id=u51598dd5&name=image.png&originHeight=951&originWidth=1643&originalType=binary&ratio=1&rotation=0&showTitle=false&size=663126&status=done&style=none&taskId=u39eef411-e001-4f24-86ec-f405edb07b5&title=&width=938.8571428571429)

### 整合Feign+Sentinel 测试熔断降级

> [https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5](https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5)

**什么是熔断降级**
除了流量控制以外，降低调用链路中的不稳定资源也是Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21571611/1652624323317-901a00eb-91ef-4abc-af29-39a17a94e747.png#clientId=u891ef93a-4d02-4&from=paste&height=289&id=u028d25b6&name=image.png&originHeight=505&originWidth=928&originalType=binary&ratio=1&rotation=0&showTitle=false&size=297458&status=done&style=none&taskId=u428b9ab1-fe2b-4af0-ba03-14ddacced5d&title=&width=530.2857142857143)
**Sentinel 和Hystrix 的原则是一致的:** 当检测到调用链路中某个资源出现不稳定的表现，例
如请求响应时间长或异常比例升高的时候，则对这个资源的调用进行限制，让请求快速失败，
避免影响到其它的资源而导致级联故障

#### 熔断降级设计理念

在限制的手段上，Sentinel 和Hystrix 采取了完全不一样的方法

Hystrix 通过线程池隔离的方式，来对依赖（在Sentinel 的概念中对应资源）进行了隔
离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成
本（过多的线程池导致线程数目过多），还需要预先给各个资源做线程池大小的分配.

> Sentinel 对这个问题采取了两种手段:
>
> - **通过并发线程数进行限制**
>
> 和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其
> 它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个
> 资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步
> 堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积
> 的线程完成任务后才开始继续接收请求
>
> - **通过响应时间对资源进行降级**
>
> 除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。
> 当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的
> 时间窗口之后才重新恢复

整合测试：
[https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/s](https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/se)entinel-example/sentinel-feign-example/readme-zh.md

1. pom依赖

```xml
<dependency>
  <groupId>com.alibaba.cloud</groupId>
  <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

# Feign 声明式远程调用

### 简介

Feign 是一个声明式的HTTP 客户端，它的目的就是让远程调用更加简单。Feign 提供了HTTP
请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP 请求的参数、格式、地
址等信息。

Feign 整合了Ribbon（负载均衡）和Hystrix(服务熔断)，可以让我们不再需要显式地使用这
两个组件。

SpringCloudFeign 在NetflixFeign 的基础上扩展了对SpringMVC 注解的支持，在其实现下，我
们只需创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。简化了
SpringCloudRibbon 自行封装服务调用客户端的开发量。

### 使用

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

### 原理

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21571611/1652625052011-a8897510-48be-46c7-a0bb-127ad647fdc4.png#clientId=u891ef93a-4d02-4&from=paste&height=698&id=ua8b7b2b1&name=image.png&originHeight=1222&originWidth=1085&originalType=binary&ratio=1&rotation=0&showTitle=false&size=556933&status=done&style=none&taskId=u43875a81-e2c9-431c-9daa-541f2a4a336&title=&width=620)

# Gateway

### 简介

> 网关作为流量的入口，常用功能包括路由转发、权限校验、限流控制等。而springcloud gateway作为SpringCloud 官方推出的第二代网关框架，取代了Zuul 网关

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21571611/1652625173322-73160012-8cbd-4e50-95f6-b0414b670b41.png#clientId=u891ef93a-4d02-4&from=paste&height=143&id=u58aa4ff3&name=image.png&originHeight=250&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118079&status=done&style=none&taskId=ubc9d2b01-0e0a-4c3a-b4c7-3e422b291c0&title=&width=362.85714285714283)
网关提供API 全托管服务，丰富的API 管理功能，辅助企业管理大规模的API，以降低管理
成本和安全风险，包括协议适配、协议转发、安全策略、防刷、流量、监控日志等功能。

Spring Cloud Gateway 旨在提供一种简单而有效的方式来对API 进行路由，并为他们提供切
面，例如：安全性，监控/指标和弹性等。

> 官方文档地址：
> [https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.3.RELEASE/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.3.RELEASE/single/spring-cloud-gateway.html)


> Spring Cloud Gateway 特点:
>
> - 基于Spring5，支持响应式编程和SpringBoot2.0
> - 支持使用任何请求属性进行路由匹配
> - 特定于路由的断言和过滤器
> - 集成Hystrix 进行断路保护
> - 集成服务发现功能
> - 易于编写Predicates 和Filters
> - 支持请求速率限制
> - 支持路径重写

思考:
为什么使用API 网关？
API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部
客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服
务通信，会有以下的问题：

- 客户端会多次请求不同的微服务，增加了客户端的复杂性
- 存在跨域请求，在一定场景下处理相对复杂
- 认证复杂，每个服务都需要独立认证
- 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合

并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将
会很难实施

- 某些微服务可能使用了防火墙/ 浏览器不友好的协议，直接访问会有一定的困难

以上这些问题可以借助API 网关解决。API 网关是介于客户端和服务器端之间的中间层，
所有的外部请求都会先经过API 网关这一层。也就是说，API 的实现方面更多的考虑业务
逻辑，而安全、性能、监控可以交由API 网关来做，这样既提高业务灵活性又不缺安全性：
使用API 网关后的优点如下：

- 易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析
- 易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证
- 减少了客户端与各个微服务之间的交互次数

### 核心概念

- 路由。路由是网关最基础的部分，路由信息有一个ID、一个目的URL、一组断言和一组Filter 组成。如果断言路由为真，则说明请求的URL 和配置匹配
- 断言。Java8 中的断言函数。Spring Cloud Gateway 中的断言函数输入类型是Spring5.0 框架中的ServerWebExchange。Spring Cloud Gateway 中的断言函数允许开发者去定义匹配来自于http request 中的任何信息，比如请求头和参数等
- 过滤器。一个标准的Spring webFilter。Spring cloud gateway 中的filter 分为两种类型的Filter，分别是Gateway Filter 和Global Filter。过滤器Filter 将会对请求和响应进行修改处理

工作原理：
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21571611/1652626702973-6f9e9ae6-2efe-4cc6-acad-06de4d873184.png#clientId=u891ef93a-4d02-4&from=paste&height=659&id=u53d16ebf&name=image.png&originHeight=1154&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=192719&status=done&style=none&taskId=u6dea4280-214b-4b27-92ab-16a7c5874e6&title=&width=593.1428571428571)
客户端发送请求给网关，弯管HandlerMapping 判断是否请求满足某个路由，满足就发给网
关的WebHandler。这个WebHandler 将请求交给一个过滤器链，请求到达目标服务之前，会
执行所有过滤器的pre 方法。请求到达目标服务处理之后再依次执行所有过滤器的post 方
法

> 一句话：满足某些断言（predicates）就路由到指定的地址（uri），使用指定的过滤器（filter）

### 3. 使用

```xml
<!--getway网关依赖-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```