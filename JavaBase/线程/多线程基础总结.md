# 程序、进程、线程

### 程序

> 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指**一段静态的代码**，静态对象。



### 进程

> 进程(process)是程序的一次执行过程，或是**正在运行的一个程序**。是一个动态的过程：有它自身的产生、存在和消亡的过程。 ——生命周期

如：运行中的QQ，运行中的MP3播放器

- 程序是静态的，进程是动态的
- 进程作为资源分配的单位， 系统在运行时会为每个进程分配不同的内存区域



### 线程

> 线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。

- 若一个进程同一时间并行执行多个线程，就是支持多线程的
- **线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小
- 一个进程中的多个线程共享相同的内存单元/内存地址空间。它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但**多个线程操作共享的系统资源可能就会带来安全的隐患**。

**一个Java应用程序java.exe，其实至少有三个线程： main()主线程， gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。** 

> 狂神说：Java默认有几个线程？**2个线程！** main线程、GC线程



## 图解单线程与多线程

<img src="images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202108211016610.png" alt="image-20200608185019405" style="zoom:50%;" />



## 单核CPU和多核CPU的理解

- 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。

  例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱， 那么收费人员可以把他"挂起"(晾着他，等他想通了，准备好了钱，再去收费) 。 但是因为CPU时间单元特别短，因此感觉不出来。

- 如果是多核的话，才能更好的发挥多线程的效率。(现在的服务器都是多核的)



## 并行与并发

>  并行： 多个CPU同时执行多个任务。比如：多个人同时做不同的事。

CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。

> 并发： 一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。

CPU多核，多个线程可以同时执行。 我们可以使用线程池！



## 多线程程序的优点

以单核CPU为例， 只使用单个线程先后完成多个任务(调用多个方法)，肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？

1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
2. 提高计算机系统CPU的利用率
3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改



## 何时需要使用多线程？

1. 程序需要同时执行两个或多个任务。
2. 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。
3. 需要一些后台运行的程序时。



## Thread类

### Thread类的特性

Java语言的JVM允许程序运行多个线程，它通过`java.lang.Thread`类来体现

1. 每个线程都是通过某个特定Thread对象的`run()`方法来完成操作的，经常把`run()`方法的主体称为线程体
2. 通过该Thread对象的`start()`方法来启动这个线程，而非直接调用`run()`

### 构造器

| 构造器                               | 备注                                                    |
| ------------------------------------ | ------------------------------------------------------- |
| Thread()                             | 创建新的Thread对象                                      |
| Thread(String threadname)            | 创建线程并指定线程实例名                                |
| Thread(Runnable target)              | 指定创建线程的目标对象，它实现了Runnable接口中的run方法 |
| Thread(Runnable target, String name) | 创建新的Thread对象                                      |

### 方法

| 方法                           | 备注                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| void start()                   | 启动线程，并执行对象的run()方法                              |
| run()                          | 线程在被调度时执行的操作                                     |
| String getName()               | 返回线程的名称                                               |
| void setName(String name)      | 设置该线程名称                                               |
| static Thread currentThread()  | 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类 |
| static void yield()            | 线程让步<br/>1. 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程<br/>2. 若队列中没有同优先级的线程，忽略此方法 |
| join()                         | 当某个程序执行流中调用其他线程的 join() 方法时， 调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止(低优先级的线程也可以获得执行) |
| static void sleep(long millis) | (指定时间:毫秒) 1.令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。2.抛出InterruptedException异常 |
| stop()                         | 强制线程生命期结束，**不推荐使用**                           |
| boolean isAlive()              | 返回boolean，判断线程是否还活着                              |



## 多线程的创建

JDK1.5之前创建新执行线程有两种方法：

1. 继承Thread类的方式
2. 实现Runnable接口的方式
3. 实现Callable接口(JDK 5.0新增)
4. 使用线程池(JDK 5.0新增)



### 方式一：继承于Thread类

#### 创建流程

1. 创建一个继承于Thread类的子类

2. **重写Thread类的run()** --> 将此线程执行的操作声明在run()中

3. 创建Thread类的子类的对象

4. 通过此对象调用start()

#### 实例演示

```java
//1. 创建一个继承于Thread类的子类
class MyThread extends Thread {
    //2. 重写Thread类的run()
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}

public class ThreadTest {
    public static void main(String[] args) {
        //3. 创建Thread类的子类的对象
        MyThread t1 = new MyThread();

        //4.通过此对象调用start():①启动当前线程 ② 调用当前线程的run()
        t1.start();
        //问题一：我们不能通过直接调用run()的方式启动线程。
//        t1.run();

        //问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。会报IllegalThreadStateException
//        t1.start();
        //我们需要重新创建一个线程的对象
        MyThread t2 = new MyThread();
        t2.start();

        //如下操作仍然是在main线程中执行的。
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i + "***********main()************");
            }
        }
    }

}
```

#### 注意事项

1. 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。
2. run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。
3. 想要启动多线程，必须调用`start`方法。
4. 一个线程对象只能调用一次`start()`方法启动，如果重复调用了，则将抛出以上的异常"`IllegalThreadStateException`" 。



### 方式二：实现Runnable接口

#### 创建流程

1. 创建一个实现了Runnable接口的类

2. **实现类去实现Runnable中的抽象方法：run()**

3. 创建实现类的对象

4. **将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象**

5. 通过Thread类的对象调用start()



#### 实例演示

```java
//1. 创建一个实现了Runnable接口的类
class MThread implements Runnable{

    //2. 实现类去实现Runnable中的抽象方法：run()
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }

        }
    }
}

public class ThreadTest1 {
    public static void main(String[] args) {
        //3. 创建实现类的对象
        MThread mThread = new MThread();
        //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
        Thread t1 = new Thread(mThread);
        t1.setName("线程1");
        //5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()-->调用了Runnable类型的target的run()
        t1.start();

        //再启动一个线程，遍历100以内的偶数
        Thread t2 = new Thread(mThread);
        t2.setName("线程2");
        t2.start();
    }

}
```

### 继承Thread类VS实现Runnable接口

**相同点：**

两种方式都需要重写`run()`，将线程要执行的逻辑声明在`run()`中。

**不同点：**

1. 继承Thread：线程代码存放Thread子类run方法中。
2. 实现Runnable：线程代码存在接口的子类的run方法。

**联系：**

`public class Thread implements Runnable`

**优先选择：实现Runnable接口的方式**

**原因：**

1. 实现的方式没有类的单继承性的局限性   
2. 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。



### 方式三：实现Callable接口(JDK 5.0新增)

详情参看下文：  [Callable](#Callable)

### 方式四：使用线程池(JDK 5.0新增)

详情参看下文：   [线程池](#线程池)

## 线程的开启

### JAVA真的可以开启线程吗？开不了的！

```java
public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
	//这是一个C++底层，Java是没有权限操作底层硬件的
    private native void start0();
```

Java是没有权限去开启线程、操作硬件的，`start0()`这是一个native的一个本地方法，它调用的底层的C++代码。



## 线程的调度策略

**时间片**

同优先级线程组成先进先出队列(先到先服务)，使用时间片策略

![image-20200608204627166](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/20200726214644.png)



**抢占式** 

对高优先级，使用优先调度的抢占式策略，高优先级的线程抢占CPU



## 线程的优先级

### 线程的优先级等级

`MAX_PRIORITY`： 10
`MIN _PRIORITY`： 1
`NORM_PRIORITY`： 5

### 涉及的方法

`getPriority() `： 获取线程的优先级
`setPriority(int newPriority) `： 设置线程的优先级

### 说明

1. 线程创建时继承父线程的优先级
2. 高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。



## 线程的分类

Java中的线程分为两类：一种是**守护线程**，一种是**用户线程**。

- 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。
- 守护线程是用来服务用户线程的，通过在`start()`方法前调用`thread.setDaemon(true)`可以把一个用户线程变成一个守护线程。
- Java垃圾回收就是一个典型的守护线程。
- JVM会在所有的非守护线程(用户线程)执行完毕后退出；
- main线程是用户线程；
  - 仅有main线程一个用户线程执行完毕，不能决定JVM是否退出，也即是说main线程并不一定是最后一个退出的线程
  - @Test 修饰的方法 多线程都是守护线程所以 当测试方法完成后就会退出 而main方法是用户线程，多线程也都是用户线程

## 线程的生命周期(状态)

**源码分析**

JDK中用`Thread.State`类定义了线程的几种状态

```java
public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
    	//初始
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
    	//运行
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
    	//阻塞
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
    	//等待
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
    	//超时等待
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
    	//终止
        TERMINATED;
    }
```



**另一种说法**

要想实现多线程， 必须在主线程中创建新的线程对象。 Java语言使用Thread类及其子类的对象来表示线程， 在它的一个完整的生命周期中通常要经历如下的五种状态：

1. **新建**： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
2. **就绪**： 处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源
3. **运行**： 当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能
4. **阻塞**： 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态
5. **死亡**： 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束

![image-20200608211039799](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/20200726214647.png)



## ==线程同步及线程安全==

### 线程安全问题

#### 产生的原因？

1. 多个线程执行的不确定性引起执行结果的不稳定
2. 多个线程对数据的共享，会造成操作的不完整性，会破坏数据。

当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。

#### 实例(买票的超卖问题)

```java
/**
 * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式
 *
 * 存在线程的安全问题，待解决。
 */
class Window extends Thread{

    private static int ticket = 100;
    @Override
    public void run() {

        while(true){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if(ticket > 0){
                System.out.println(getName() + "：卖票，票号为：" + ticket);
                ticket--;
            }else{
                break;
            }
        }

    }
}

public class WindowTest {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}

```

**结果**

出现了共享数据错误

```
窗口2：卖票，票号为：100
窗口1：卖票，票号为：100
窗口3：卖票，票号为：98
窗口3：卖票，票号为：97
窗口2：卖票，票号为：97
窗口1：卖票，票号为：95
窗口1：卖票，票号为：94
窗口2：卖票，票号为：93
窗口3：卖票，票号为：92
窗口3：卖票，票号为：91
......
窗口1：卖票，票号为：10
窗口3：卖票，票号为：10
窗口2：卖票，票号为：10
窗口2：卖票，票号为：7
窗口3：卖票，票号为：7
窗口1：卖票，票号为：5
窗口3：卖票，票号为：4
窗口2：卖票，票号为：4
窗口1：卖票，票号为：2
窗口2：卖票，票号为：1
窗口3：卖票，票号为：1
```

**分析**

1. 问题：三条线程同时共享ticket的票，卖票过程中，出现了重票、错票 -->出现了线程的安全问题，导致数据错误。
2. 原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。
3. 解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。

#### 如何确定是否存在线程安全问题？

- 明确哪些代码是多线程运行的代码

- 明确多个线程是否有共享数据

- 明确多线程运行代码中是否有多条语句操作共享数据

#### 如何解决线程安全问题？

对多条操作共享数据的语句， 只能让一个线程都执行完， 在执行过程中， 其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中

**切记：**

- 范围太小：没锁住所有有安全问题的代码
- 范围太大：没发挥多线程的功能。 



### 线程同步

Java对于多线程的安全问题提供了专业的解决方式： **同步机制**

#### 方式一：同步代码块

```java
synchronized (对象){
	// 需要被同步的代码；
}
```

**说明**

1. 操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。

2. 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。

3. 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。

要求：多个线程必须要共用同一把锁。

补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。

##### 示例：实现Runnable

```java
class Window1 implements Runnable{

    private int ticket = 100;
//    Object obj = new Object();
    
    @Override
    public void run() {
        while(true){
            //此时的this:唯一的Window1的对象 ，方式二：synchronized (obj)
            synchronized (this){ 
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}

public class WindowTest1 {
    public static void main(String[] args) {
        Window1 w = new Window1();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }

}
```

##### 示例：继承Thread

**使用同步代码块解决继承Thread类的方式的线程安全问题。在继承Thread类创建多线程的方式中，慎用this充当同步监视器(this可能代表不同的对象)，考虑使用当前类充当同步监视器。**

```java
class Window2 extends Thread{

    private static int ticket = 100;

    private static Object obj = new Object();

    @Override
    public void run() {
        while(true){
            //正确的
//            synchronized (obj){
            synchronized (Window2.class){//Class clazz = Window2.class,Window2.class只会加载一次
                //错误的方式：this代表着t1,t2,t3三个对象
//              synchronized (this){
                if(ticket > 0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(getName() + "：卖票，票号为：" + ticket);
                    ticket--;
                }else{
                    break;
                }
            }
        }
    }
}

public class WindowTest2 {
    public static void main(String[] args) {
        Window2 t1 = new Window2();
        Window2 t2 = new Window2();
        Window2 t3 = new Window2();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}

```



#### 方式二：同步方法

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

```java
public synchronized void show (String name){

}
```

##### 示例：使用同步方法解决实现Runnable接口的线程安全问题

```java
class Window3 implements Runnable {

    private int ticket = 100;

    @Override
    public void run() {
        while (true) {
            show();
        }
    }
    private synchronized void show(){//同步监视器：this
        //synchronized (this){
            if (ticket > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                ticket--;
            }
        //}
    }
}

public class WindowTest3 {
    public static void main(String[] args) {
        Window3 w = new Window3();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

```

###### 说明

    1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
   2. 非静态的同步方法，同步监视器是：this静态的同步方法，同步监视器是：当前类本身

##### 示例：使用同步方法处理继承Thread类的方式中的线程安全问题

继承方式实现多线程，同步方法最好声明成静态的

```java
class Window4 extends Thread {

    private static int ticket = 100;

    @Override
    public void run() {
        while (true) {
            show();
        }
    }
    private static synchronized void show(){//同步监视器：Window4.class
        //private synchronized void show(){ //同步监视器：t1,t2,t3。此种解决方式是错误的
        if (ticket > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "：卖票，票号为：" + ticket);
            ticket--;
        }
    }
}

public class WindowTest4 {
    public static void main(String[] args) {
        Window4 t1 = new Window4();
        Window4 t2 = new Window4();
        Window4 t3 = new Window4();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

线程就是一个单独的资源类，没有任何的附属操作！

```java
/**
 * 真正的多线程开发
 * 线程就是一个单独的资源类，没有任何的附属操作！
 */
public class SaleTicketDemo01 {
    public static void main(String[] args) {
        //多线程操作
        //并发：多线程操作同一个资源类，把资源类丢入线程
        Ticket ticket = new Ticket();

        //@FunctionalInterface 函数式接口 jdk1.8之后 lambda表达式
        new Thread(()->{
            for(int i=0;i<40;i++){
                ticket.sale();
            }
        },"A").start();
        new Thread(()->{
            for(int i=0;i<40;i++){
                ticket.sale();
            }
        },"B").start();
        new Thread(()->{
            for(int i=0;i<40;i++){
                ticket.sale();
            }
        },"C").start();
    }
}
//资源类
//属性+方法
//oop
class Ticket{
    private int number=50;

    //卖票的方式
    // synchronized 本质：队列，锁
    public synchronized void sale(){
        if(number>0){
            System.out.println(Thread.currentThread().getName()+" 卖出了第"+number+" 张票,剩余："+number+" 张票");
            number--;
        }
    }
}
```



#### 方式三：Lock(锁)(JDK5.0新增)

详情见下文JUC中对Lock(锁)的介绍： [Lock锁(重点)](#Lock锁(重点))



### 同步机制

#### 同步锁机制

在《Thinking in Java》 中， 是这么说的：对于并发工作， **你需要某种方式来防止两个任务访问相同的资源(其实就是共享资源竞争) 。 防止这种冲突的方法就是当资源被一个任务使用时， 在其上加锁**。 第一个访问某项资源的任务必须锁定这项资源， 使其他任务在其被解锁之前， 就无法访问它了， 而在其被解锁之时， 另一个任务就可以锁定并使用它了。

#### 注意事项：

1. **必须确保使用同一个资源的多个线程共用一把锁**， 这个非常重要， 否则就无法保证共享资源的安全
2. 一个线程类中的所有静态方法共用同一把锁(类名.class) ， 所有非静态方法共用同一把锁(this) ， 同步代码块(指定需谨慎)

#### 同步方式的优缺点

**优点**

同步的方式，解决了线程的安全问题。

**缺点**

操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 



### ==synchronized==

#### 释放锁的操作

- 当前线程的同步方法、同步代码块执行结束。
- 当前线程在同步代码块、同步方法中遇到break、 return终止了该代码块、该方法的继续执行。
- 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception， 导致异常结束。
- 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。

#### 不会释放锁的操作

- 线程执行同步代码块或同步方法时，程序调用`Thread.sleep()`、`Thread.yield()`方法暂停当前线程的执行
- 线程执行同步代码块时，其他线程调用了该线程的`suspend()`方法将该线程挂起，该线程不会释放锁(同步监视器)。
  - 应尽量避免使用`suspend()`和`resume()`来控制线程

#### synchronized锁的对象

**Java中的每一个对象都可以作为锁。具体表现为以下3种形式。**

- 对于普通同步方法，锁是当前实例对象。

- 对于静态同步方法，锁是当前类的Class对象。

- 对于同步方法块，锁是Synchonized括号里配置的对象。



#### 原理

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。



### ==死锁(synchronized)==

这里只简单阐述synchronized引发的死锁问题，更详细的会在下文的JUC的死锁问题进行研究。

##### 问题

- 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
- 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续

##### 示例

```java
//死锁的演示
class A {
	public synchronized void foo(B b) { //同步监视器：A类的对象：a
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 进入了A实例的foo方法"); // ①
		try {
			Thread.sleep(200);
		} catch (InterruptedException ex) {
			ex.printStackTrace();
		}
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 企图调用B实例的last方法"); // ③
		b.last();
	}

	public synchronized void last() {//同步监视器：A类的对象：a
		System.out.println("进入了A类的last方法内部");
	}
}

class B {
	public synchronized void bar(A a) {//同步监视器：b
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 进入了B实例的bar方法"); // ②
		try {
			Thread.sleep(200);
		} catch (InterruptedException ex) {
			ex.printStackTrace();
		}
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 企图调用A实例的last方法"); // ④
		a.last();
	}

	public synchronized void last() {//同步监视器：b
		System.out.println("进入了B类的last方法内部");
	}
}

public class DeadLock implements Runnable {
	A a = new A();
	B b = new B();

	public void init() {
		Thread.currentThread().setName("主线程");
		// 调用a对象的foo方法
		a.foo(b);
		System.out.println("进入了主线程之后");
	}

	@Override
	public void run() {
		Thread.currentThread().setName("副线程");
		// 调用b对象的bar方法
		b.bar(a);
		System.out.println("进入了副线程之后");
	}

	public static void main(String[] args) {
		DeadLock dl = new DeadLock();
		new Thread(dl).start();
		
		dl.init();
	}
}
```

###### 结果

线程死锁，程序不会正常停止

![image-20200608222839529](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/20200726214659.png)

##### 解决办法

1. 专门的算法、原则
2. 尽量减少同步资源的定义
3. 尽量避免嵌套同步



## 线程通信

线程通信，即线程交替执行

### wait() 与 notify() 和 notifyAll()

- **`wait()`**：令当前线程挂起并放弃CPU、 同步资源并等待， 使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。(一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。)
- **`notify()`**：唤醒正在排队等待同步资源的线程中优先级最高者结束等待。(一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。)
- **`notifyAll ()`**：唤醒正在排队等待资源的所有线程结束等待。(一旦执行此方法，就会唤醒所有被wait的线程。)

**wait()**

- 在当前线程中调用方法： `对象名.wait()`
- 使当前线程进入等待(某对象)状态 ，直到另一线程对该对象发出 `notify`(或`notifyAll`) 为止。
- 调用方法的必要条件：**当前线程必须具有对该对象的监控权(加锁)**
- 调用此方法后，当前线程将**释放对象监控权 ，然后进入等待**
- 在当前线程被`notify`后，要重新获得监控权，然后从断点处继续代码的执行。

**notify()/notifyAll()**

- 在当前线程中调用方法： `对象名.notify()`
- 功能：唤醒等待该对象监控权的一个/所有线程。
- 调用方法的必要条件：当前线程必须具有对该对象的监控权(加锁)

**注意事项**

1. 这三个方法只有在`synchronized方法`或`synchronized代码块`中才能使用，调用者必须是同步代码块或同步方法中的同步监视器，否则会报`java.lang.IllegalMonitorStateException`异常。
2. 因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法**只能在Object类中声明**(定义在java.lang.Object类中)。 

### 示例1——交替打印

使用两个线程打印 1-100。线程1, 线程2 交替打印

```java
class Number implements Runnable{
    private int number = 1;
    private Object obj = new Object();
    @Override
    public void run() {
        while(true){
            synchronized (obj) {
                obj.notify();
                if(number <= 100){
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":" + number);
                    number++;
                    try {
                        //使得调用如下wait()方法的线程进入阻塞状态
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else{
                    break;
                }
            }
        }
    }
}

public class CommunicationTest {
    public static void main(String[] args) {
        Number number = new Number();
        Thread t1 = new Thread(number);
        Thread t2 = new Thread(number);

        t1.setName("线程1");
        t2.setName("线程2");

        t1.start();
        t2.start();
    }
}

```

**结果**

```java
线程1:1
线程2:2
线程1:3
线程2:4
线程1:5
线程2:6
线程1:7
线程2:8
线程1:9
线程2:10
线程1:11
线程2:12
线程1:13
......
线程1:95
线程2:96
线程1:97
线程2:98
线程1:99
线程2:100
```



### 示例2——生产者/消费者问题

```java
/**
 * 线程通信的应用：经典例题：生产者/消费者问题
 *
 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，
 * 店员一次只能持有固定数量的产品(比如:20)，如果生产者试图生产更多的产品，店员
 * 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品
 * 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。
 *
 * 分析：
 * 1. 是否是多线程问题？是，生产者线程，消费者线程
 * 2. 是否有共享数据？是，店员(或产品)
 * 3. 如何解决线程的安全问题？同步机制,有三种方法
 * 4. 是否涉及线程的通信？是
 */
class Clerk{

    private int productCount = 0;
    //生产产品
    public synchronized void produceProduct() {
        if(productCount < 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + ":开始生产第" + productCount + "个产品");
            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //消费产品
    public synchronized void consumeProduct() {
        if(productCount > 0){
            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");
            productCount--;
            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Producer extends Thread{//生产者

    private Clerk clerk;
    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }
    @Override
    public void run() {
        System.out.println(getName() + ":开始生产产品.....");
        while(true){
           try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.produceProduct();
        }

    }
}

class Consumer extends Thread{//消费者
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }
    @Override
    public void run() {
        System.out.println(getName() + ":开始消费产品.....");
        while(true){
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumeProduct();
        }
    }
}

public class ProductTest {

    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");
        Consumer c2 = new Consumer(clerk);
        c2.setName("消费者2");

        p1.start();
        c1.start();
        c2.start();

    }
}

```

**可能出现的问题**

1. 生产者比消费者快时，消费者会漏掉一些数据没有取到。
2. 消费者比生产者快时，消费者会取相同的数据。.



## 面试题1：sleep() 和 wait()的异同？

相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。

不同点：

1. 两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()
2. 调用的要求不同(使用范围不同)：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
3. 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。



## Sleep的使用技巧

```java
TimeUnit.DAYS.sleep(1); //休眠1天
TimeUnit.SECONDS.sleep(1); //休眠1s
```



## ==线程池==

### 为什么要使用线程池？

经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 ===> 池化技术

提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。

**优点**

- 提高响应速度(减少了创建新线程的时间)
- 降低资源消耗(重复利用线程池中线程，不需要每次都创建)
- 便于线程管理
  - corePoolSize：核心池的大小
  - maximumPoolSize：最大线程数
  - keepAliveTime：线程没有任务时最多保持多长时间后会终止
  - …



### 线程池相关API

#### 创建线程池

- JDK 5.0起提供了线程池相关API：` ExecutorService` 和 `Executors`
- `ExecutorService`：真正的线程池接口。常见子类`ThreadPoolExecutor`
  - `void execute(Runnable command)` ：执行任务/命令，没有返回值，一般用来执行`Runnable`
  - `<T> Future<T> submit(Callable<T> task)`：执行任务，有返回值，一般又来执行`Callable`
  - `void shutdown() `：关闭连接池
- `Executors`：工具类、线程池的工厂类，用于创建并返回不同类型的线程池
  - `Executors.newCachedThreadPool()`：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 (可根据需要创建新线程的线程池)
    - 创建方式： `Executors.newCachedThreadPool()`；
  - `Executors.newFixedThreadPool(n)`: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置，如`Runtime.getRuntime().availableProcessors()`。 
    - 创建方式： `Executors.newFixedThreadPool()`；
  - `Executors.newSingleThreadExecutor()` ：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 
    - 创建方式： `Executors.newSingleThreadExecutor ()`；
  - `Executors.newScheduledThreadPool(n)`：创建一个定长线程池，支持定时及周期性任务执行。 
    - 创建方式： `Executors.newScheduledThreadPool ()`；

##### 源码分析

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

本质：三种方法都是开启的**ThreadPoolExecutor**

```java
public ThreadPoolExecutor(int corePoolSize,  //核心线程池大小
                          int maximumPoolSize, //最大的线程池大小
                          long keepAliveTime,  //超时了没有人调用就会释放
                          TimeUnit unit, //超时单位
                          BlockingQueue<Runnable> workQueue, //阻塞队列
                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动
                          RejectedExecutionHandler handler //拒绝策略
                         ) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```



##### Executors说明

Executors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，也就是上面所说的四种Executors线程池，但是 ThreadPoolExecutor 提供的功能远不止于此。

#### 线程池的一些问题

```java
class NumberThread implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

public class ThreadPool {

    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
//        System.out.println(service.getClass());
//        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();

        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable

//        service.submit(Callable callable);//适合使用于Callable
        //3.关闭连接池
        service.shutdown();
    }

}
```

##### 问题

但是在使用`Executors`创建线程池的时候，阿里巴巴开发规范并不推荐这样去使用

![image-20200609114828157](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/20200726214707.png)

###### 具体警告如下

```java
线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下：
1)FixedThreadPool和SingleThreadPool:
  允许的请求队列长度为Integer.MAX_VALUE(约为21亿)，可能会堆积大量的请求，从而导致OOM。
2)CachedThreadPool:
  允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。
            
Positive example 1：
    //org.apache.commons.lang3.concurrent.BasicThreadFactory
    ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,
        new BasicThreadFactory.Builder().namingPattern("example-schedule-pool-%d").daemon(true).build());
                         
Positive example 2：
    ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
        .setNameFormat("demo-pool-%d").build();

    //Common Thread Pool
    ExecutorService pool = new ThreadPoolExecutor(5, 200,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());

    pool.execute(()-> System.out.println(Thread.currentThread().getName()));
    pool.shutdown();//gracefully shutdown
                  
Positive example 3：
    <bean id="userThreadPool"
        class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
        <property name="corePoolSize" value="10" />
        <property name="maxPoolSize" value="100" />
        <property name="queueCapacity" value="2000" />

    <property name="threadFactory" value= threadFactory />
        <property name="rejectedExecutionHandler">
            <ref local="rejectedExecutionHandler" />
        </property>
    </bean>
    //in code
    userThreadPool.execute(thread);
```

##### 分析

在创建线程池的时候，大部分人还是会选择使用`Executors`去创建。

下面是创建定长线程池(FixedThreadPool)的一个例子，严格来说，当使用如下代码创建线程池时，是不符合编程规范的。

```java
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
```

###### 原因：

线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下：
1)FixedThreadPool和SingleThreadPool:
  允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
2)CachedThreadPool:
  允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。

###### 弊端

1. `SingleThreadPool`只有一个线程在处理任务，如果达到了`FixedThreadPool`设置的线程最大数量，线程就会等待。所以如果任务比较多的时候，就可能造成任务(请求)堆积，造成内存溢出(OOM)。

2. `CachedThreadPool`创建可缓存的线程池，线程没有限制，如果任务比较多，就会造成创建大量的线程而造成内存溢出。



##### OOM

Out Of Memory，一般是由于程序编写者对内存使用不当，如对该释放的内存资源没有释放，导致其一直不能被再次使用而使计算机内存被耗尽的现象。



所以可以使用`ThreadPoolExecutor`创建线程池。



#### 通过ThreadPoolExecutor创建线程池

`java.uitl.concurrent.ThreadPoolExecutor`类是线程池中最核心的一个类。

##### 构造方法

```java
public class ThreadPoolExecutor extends AbstractExecutorService {

    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);

}
```

`ThreadPoolExecutor`继承了`AbstractExecutorService`类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。

###### 构造器各个参数含义

- **corePoolSize**：核心池的大小。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
- **maximumPoolSize**：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
- **keepAliveTime**：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
- **unit**：参数keepAliveTime的时间单位，有7种取值。TimeUnit.DAYS、TimeUnit.HOURS、TimeUnit.MINUTES、TimeUnit.SECONDS、TimeUnit.MILLISECONDS、TimeUnit.MICROSECONDS、TimeUnit.NANOSECONDS
- **workQueue**：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue。 
  ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。
- **threadFactory**：线程工厂，主要用来创建线程；
- **handler**：表示当拒绝处理任务时的策略，有以下四种取值： 
  - ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
  - ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
  - ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行此任务(重复此过程) 
  - ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，可以保证任务都被执行，但是可能会有一定的延迟。

![线程池原理](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202109261001194.png)

##### ThreadPoolExecutor类中几个重要方法

1. execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。 
2. submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果(Future相关内容将在下一篇讲述)。 

3. shutdown()和shutdownNow()是用来关闭线程池的。 

4. 还有一大波get的方法， 可以获取与线程池相关属性的方法。



##### 示例1

```java
/**
 * 测试ThreadPoolExecutor对线程的执行顺序
 **/
public class ThreadPoolSerialTest {
    public static void main(String[] args) {
        //核心线程数
        int corePoolSize = 3;
        //最大线程数
        int maximumPoolSize = 6;
        //超过 corePoolSize 线程数量的线程最大空闲时间
        long keepAliveTime = 2;
        //以秒为时间单位
        TimeUnit unit = TimeUnit.SECONDS;
        //创建工作队列，用于存放提交的等待执行任务
        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<Runnable>(2);
        ThreadPoolExecutor threadPoolExecutor = null;
        try {
            //创建线程池
            threadPoolExecutor = new ThreadPoolExecutor(corePoolSize,
                    maximumPoolSize,
                    keepAliveTime,
                    unit,
                    workQueue,
                    new ThreadPoolExecutor.AbortPolicy());

            //循环提交任务
            for (int i = 0; i < 8; i++) {
                //提交任务的索引
                final int index = (i + 1);
                threadPoolExecutor.submit(() -> {
                    //线程打印输出
                    System.out.println("大家好，我是线程：" + index);
                    try {
                        //模拟线程执行时间，10s
                        Thread.sleep(10000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
                //每个任务提交后休眠500ms再提交下一个任务，用于保证提交顺序
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            threadPoolExecutor.shutdown();
        }
    }
}
```

![image-20200609161521764](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/20200726214713.png)

##### 示例2——银行排队

理解四种拒绝策略

```java
/**
 * new ThreadPoolExecutor.AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异常
 * new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的去哪里！
 * new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！
 * new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试去和最早的竞争，也不会抛出异常！
 */
public class Demo01 {
    public static void main(String[] args) {
        // 自定义线程池！工作 ThreadPoolExecutor

        // 最大线程到底该如何定义
        // 1、CPU 密集型，几核，就是几，可以保持CPu的效率最高！
        // 2、IO  密集型   > 判断你程序中十分耗IO的线程，
        // 程序   15个大型任务  io十分占用资源！

        // 获取CPU的核数
        System.out.println(Runtime.getRuntime().availableProcessors());

        List  list = new ArrayList();

        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                Runtime.getRuntime().availableProcessors(),
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardOldestPolicy());  //队列满了，尝试去和最早的竞争，也不会抛出异常！
        try {
            // 最大承载：Deque + max
            // 超过 RejectedExecutionException
            for (int i = 1; i <= 9; i++) {
                // 使用了线程池之后，使用线程池来创建线程
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+" ok");
                });
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }

    }
}

```



#### 如何去设置线程池的最大大小如何去设置？

**1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小**

**2、I/O密集型：在程序中有15个大型任务，io十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约是最大I/O数的一倍到两倍之间。**

#### 线程池小结

1. Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的； 
2. 然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等； 
3. 抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法； 
4. 然后ThreadPoolExecutor继承了类AbstractExecutorService。



# JUC(多线程与高并发进阶)

## 什么是JUC？

> JUC是 java util concurrent

![image-20200812203120902](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200812203120902.png)

## Java获取CPU核数

```java
Runtime.getRuntime().availableProcessors()
```



## Lock锁(重点)

### 基本介绍

- 从JDK 5.0开始， Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。
- `java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具。 锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。
- `ReentrantLock` 类实现了 Lock ，它拥有与 `synchronized` 相同的并发性和内存语义， 在实现线程安全的控制中，比较常用的是`ReentrantLock`， 可以显式加锁、释放锁。
  -  `ReentrantLock`默认的构造方法是非公平锁，如下源码分析

```java
	/**
     * Creates an instance of {@code ReentrantLock}.
     * This is equivalent to using {@code ReentrantLock(false)}.
     */
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    /**
     * Creates an instance of {@code ReentrantLock} with the
     * given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
```

### 公平锁和非公平锁

**公平锁：** 十分公平，必须先来后到；

**非公平锁：** 十分不公平，可以插队；**(默认为非公平锁)**

```java
public class SaleTicketDemo02 {
    public static void main(String[] args) {
        //多线程操作
        //并发：多线程操作同一个资源类，把资源类丢入线程
        Ticket2 ticket = new Ticket2();
        new Thread(()->{for(int i=0;i<40;i++) ticket.sale(); },"A").start();
        new Thread(()->{for(int i=0;i<40;i++) ticket.sale(); },"B").start();
        new Thread(()->{for(int i=0;i<40;i++) ticket.sale(); },"C").start();
    }
}

//lock三部曲
//1、    Lock lock=new ReentrantLock();
//2、    lock.lock() 加锁
//3、    finally=> 解锁：lock.unlock();
class Ticket2{
    private int number=50;

    Lock lock=new ReentrantLock();

    //卖票的方式
    // 使用Lock 锁
    public void sale(){
        //加锁
        lock.lock();
        try {
            //业务代码
            if(number>=0){
                System.out.println(Thread.currentThread().getName()+" 卖出了第"+number+" 张票,剩余："+number+" 张票");
                number--;
            }
        }catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            //解锁
            lock.unlock();
        }
    }
}
```



### 分类

![在这里插入图片描述](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjE3ODQ4,size_16,color_FFFFFF,t_70.png)



### 如何使用？

```java
class A{
    private final ReentrantLock lock = new ReentrantLock();
    public void m(){
        lock.lock();
        try{
        	//保证线程安全的代码;
        }
        finally{
        	lock.unlock();
        }
    }
}
```

**注意：如果同步代码有异常，要将unlock()写入finally语句块**



## 面试题：synchronized 与 Lock 的对比

**相同：**

二者都可以解决线程安全问题

**不同：**

1. Synchronized 内置的Java关键字，Lock是一个Java类
2. Synchronized 无法判断获取锁的状态，Lock可以判断
3. Lock是显式锁(手动开启和关闭锁，别忘记关闭锁，**可能会遇到死锁**)， synchronized是隐式锁，出了作用域自动释放
4. Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁；
5. Lock只有代码块锁， synchronized有代码块锁和方法锁
6. Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；
7. 使用Lock锁， JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)

**优先使用顺序：**

Lock ——> 同步代码块(已经进入了方法体，分配了相应资源) ——> 同步方法(在方法体之外)



## 读写锁(ReadWriteLock)

先对于不加锁的情况：

如果我们做一个我们自己的cache缓存。分别有写入操作、读取操作；

我们采用五个线程去写入，使用十个线程去读取。

我们来看一下这个的效果，如果我们不加锁的情况！

```java
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache_ReadWriteLock mycache = new MyCache_ReadWriteLock();
        //开启5个线程 写入数据
        for (int i = 1; i <=5 ; i++) {
            int finalI = i;
            new Thread(()->{
                mycache.put(String.valueOf(finalI),String.valueOf(finalI));
            }).start();
        }
        //开启10个线程去读取数据
        for (int i = 1; i <=10 ; i++) {
            int finalI = i;
            new Thread(()->{
                String o = mycache.get(String.valueOf(finalI));
            }).start();
        }
    }
}

class MyCache_ReadWriteLock{
    private volatile Map<String,String> map=new HashMap<>();

    //使用读写锁
    private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();
    //普通锁
    private Lock lock=new ReentrantLock();

    public void put(String key,String value){
        //写入
        System.out.println(Thread.currentThread().getName()+" 线程 开始写入");
        map.put(key, value);
        System.out.println(Thread.currentThread().getName()+" 线程 写入OK");
    }

    public String get(String key){
        //得到
        System.out.println(Thread.currentThread().getName()+" 线程 开始读取");
        String o = map.get(key);
        System.out.println(Thread.currentThread().getName()+" 线程 读取OK");
        return o;
    }
}
```

结果：

```java
Thread-1 线程 开始写入
Thread-1 线程 写入OK
Thread-0 线程 开始写入
Thread-2 线程 开始写入
Thread-2 线程 写入OK
Thread-0 线程 写入OK
Thread-4 线程 开始写入
Thread-4 线程 写入OK
Thread-5 线程 开始读取
Thread-5 线程 读取OK
Thread-6 线程 开始读取
Thread-6 线程 读取OK
......
```

所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。我们也可以采用**synchronized**这种重量锁和轻量锁 **lock**去保证数据的可靠。

但是我们可以采用更细粒度的锁：**ReadWriteLock** 读写锁来保证

![image-20200813100700283](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813100700283.png)

```java
/**
 * 独占锁(写锁) 一次只能被一个线程占有
 * 共享锁(读锁) 多个线程可以同时占有
 * ReadWriteLock
 * 读-读  可以共存！
 * 读-写  不能共存！
 * 写-写  不能共存！
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();

        // 写入
        for (int i = 1; i <= 5 ; i++) {
            final int temp = i;
            new Thread(()->{
                myCache.put(temp+"",temp+"");
            },String.valueOf(i)).start();
        }

        // 读取
        for (int i = 1; i <= 5 ; i++) {
            final int temp = i;
            new Thread(()->{
                myCache.get(temp+"");
            },String.valueOf(i)).start();
        }

    }
}

// 加锁的
class MyCacheLock{

    private volatile Map<String,Object> map = new HashMap<>();
    // 读写锁： 更加细粒度的控制
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private Lock lock = new ReentrantLock();

    // 存，写入的时候，只希望同时只有一个线程写
    public void put(String key,Object value){
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"写入"+key);
            map.put(key,value);
            System.out.println(Thread.currentThread().getName()+"写入OK");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }

    // 取，读，所有人都可以读！
    public void get(String key){
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"读取"+key);
            Object o = map.get(key);
            System.out.println(Thread.currentThread().getName()+"读取OK");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }

}

/**
 * 自定义缓存
 */
class MyCache{

    private volatile Map<String,Object> map = new HashMap<>();

    // 存，写
    public void put(String key,Object value){
        System.out.println(Thread.currentThread().getName()+"写入"+key);
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"写入OK");
    }

    // 取，读
    public void get(String key){
        System.out.println(Thread.currentThread().getName()+"读取"+key);
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName()+"读取OK");
    }

}
```

结果：

```
1写入1
1写入OK
2写入2
2写入OK
3写入3
3写入OK
4写入4
4写入OK
1读取1
1读取OK
2读取2
2读取OK
5写入5
5写入OK
4读取4
4读取OK
3读取3
3读取OK
5读取5
5读取OK
```



## 生产者和消费者问题

### Synchronized wait notify实现(传统方式)

```java
public class A {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()->{for(int i=0;i<10;i++) {
            try {
                data.increment();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        },"A").start();
        new Thread(()->{for(int i=0;i<10;i++) {
            try {
                data.decrement();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }},"B").start();
    }
}
class Data{
    //数字  资源类
    private int number = 0;

    //+1
    public synchronized void increment() throws InterruptedException {
        if(number!=0){
            //等待操作
            this.wait();
        }
        number++;
        System.out.println(Thread.currentThread().getName()+"=>"+number);
        //通知其他线程 我+1完毕了
        this.notifyAll();
    }

    //-1
    public synchronized void decrement() throws InterruptedException {
        if(number==0){
            //等待操作
            this.wait();
        }
        number--;
        System.out.println(Thread.currentThread().getName()+"=>"+number);
        //通知其他线程  我-1完毕了
        this.notifyAll();
    }

}
```

### 虚假唤醒

![20200200107238](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/20200200107238.png)



**==解决方案==**： **if 改为while即可，防止虚假唤醒**。这样就不存在问题了：

```java
public class A {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();


        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }
}

// 判断等待，业务，通知
class Data{ // 数字 资源类

    private int number = 0;

    //+1
    public synchronized void increment() throws InterruptedException {
        while (number!=0){  //0
            // 等待
            this.wait();
        }
        number++;
        System.out.println(Thread.currentThread().getName()+"=>"+number);
        // 通知其他线程，我+1完毕了
        this.notifyAll();
    }

    //-1
    public synchronized void decrement() throws InterruptedException {
        while (number==0){ // 1
            // 等待
            this.wait();
        }
        number--;
        System.out.println(Thread.currentThread().getName()+"=>"+number);
        // 通知其他线程，我-1完毕了
        this.notifyAll();
    }

}

```

### **JUC版本的生产者和消费者问题**

**await、signal 替换 wait、notify**

![image-20200813084524835](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813084524835.png)

**通过Lock找到Condition**

![image-20200813084635161](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813084635161.png)

```java
public class B  {
    public static void main(String[] args) {
        Data2 data = new Data2();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();

    }
}

// 判断等待，业务，通知
class Data2{ // 数字 资源类

    private int number = 0;

    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    //condition.await(); // 等待
    //condition.signalAll(); // 唤醒全部
    //+1
    public void increment() throws InterruptedException {
        lock.lock();
        try {
            // 业务代码
            while (number!=0){  //0
                // 等待
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName()+"=>"+number);
            // 通知其他线程，我+1完毕了
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    //-1
    public synchronized void decrement() throws InterruptedException {
        lock.lock();
        try {
            while (number==0){ // 1
                // 等待
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName()+"=>"+number);
            // 通知其他线程，我-1完毕了
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
```

执行结果：

现在是随机执行

```
A=>1
B=>0
C=>1
B=>0
C=>1
B=>0
C=>1
B=>0
C=>1
D=>0
```

**Condition的优势**：精准的通知和唤醒的线程！

**如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~**，比如A->B->C->A

```JAVA
public class C {

    public static void main(String[] args) {
        Data3 data = new Data3();

        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.printA();
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.printB();
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.printC();
            }
        },"C").start();
    }

}

class Data3{ // 资源类 Lock

    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();
    private int number = 1; // 1A  2B  3C

    public void printA(){
        lock.lock();
        try {
            // 业务，判断-> 执行-> 通知
            while (number!=1){
                // 等待
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName()+"=>AAAAAAA");
            // 唤醒，唤醒指定的人，B
            number = 2;
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printB(){
        lock.lock();
        try {
            // 业务，判断-> 执行-> 通知
            while (number!=2){
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName()+"=>BBBBBBBBB");
            // 唤醒，唤醒指定的人，c
            number = 3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void printC(){
        lock.lock();
        try {
            // 业务，判断-> 执行-> 通知
            // 业务，判断-> 执行-> 通知
            while (number!=3){
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName()+"=>BBBBBBBBB");
            // 唤醒，唤醒指定的人，c
            number = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}

```

执行结果：

```
A=>AAAAAAA
B=>BBBBBBBBB
C=>BBBBBBBBB
A=>AAAAAAA
B=>BBBBBBBBB
C=>BBBBBBBBB
A=>AAAAAAA
B=>BBBBBBBBB
C=>BBBBBBBBB
A=>AAAAAAA
```



## 8锁现象

情况1、2说明：

- **synchronized 锁的对象是方法的调用者！**

- **谁先拿到谁执行！另外一个则等待！与执行时间的先后无关！**

  如果你认为是顺序在前？ 这个答案是错误的！

```java
/**
 * 8锁，就是关于锁的8个问题
 * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信  2/打电话
 	结果是：先发短信，如何再打电话！
 	为什么？ 如果你认为是顺序在前？ 这个答案是错误的！
 * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信  2/打电话
 	结果：还是先发短信，然后再打电话！
 	原因：并不是顺序执行！是因为synchronized 锁的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行！另外一个则等待！
 */
public class Test1 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        //锁的存在
        new Thread(()->{
            phone.sendSms();
        },"A").start();

        // 捕获
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone.call();
        },"B").start();
    }
}

class Phone{

    // synchronized 锁的对象是方法的调用者！、
    // 两个方法用的是同一个锁，谁先拿到谁执行！
    public synchronized void sendSms(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call(){
        System.out.println("打电话");
    }

}
```



情况3、4说明：

- **synchronized 锁的对象是方法的调用者！**
- **没有锁，不是同步方法，不受锁的影响。**
- **不同对象的调用加锁的同步方法不受影响。**

```java
/**
 * 3、 增加了一个普通方法后！先执行发短信还是Hello？ 普通方法
 	如果我们添加一个普通方法，那么先执行哪一个呢？
 	答案是：先执行hello，然后再执行发短信！原因是hello是一个普通方法，不受synchronized锁的影响，但是我发现，如果我把发短信里面的延迟4秒去掉，那么就会顺序执行，先执行发短信然后再执行hello，原因应该是顺序执行的原因吧,不是太理解。
 * 4、 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话
 	如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？
 	答案是：先打电话，后发短信。原因：在发短信方法中延迟了4s，又因为synchronized锁的是对象，但是我们这使用的是两个对象，所以每个对象都有一把锁，所以不会造成锁的等待。正常执行
 */
public class Test2  {
    public static void main(String[] args) {
        // 两个对象，两个调用者，两把锁！
        Phone2 phone1 = new Phone2();
        Phone2 phone2 = new Phone2();

        //锁的存在
        new Thread(()->{
            phone1.sendSms();
        },"A").start();

        // 捕获
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone2.call();
        },"B").start();
    }
}

class Phone2{

    // synchronized 锁的对象是方法的调用者！
    public synchronized void sendSms(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call(){
        System.out.println("打电话");
    }

    // 这里没有锁！不是同步方法，不受锁的影响
    public void hello(){
        System.out.println("hello");
    }

}
```



情况5、6说明：

- 静态同步方法锁的对象是类本身(Class)
- 两个对象的Class类模板只有一个，static，锁的是Class
- 静态方法用该用类去调用，即使用对象调用，也还是该类的Class对象，是同一个，所以互相之间会受到影响

```java
/**
 * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？   发短信
 * 6、两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？     发短信
 	如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？
    (1)我们先来使用一个对象调用两个方法！
    答案是：先发短信,后打电话
    (2)如果我们使用两个对象调用两个方法！
    答案是：还是先发短信，后打电话
    原因是什么呢？ 为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？
    原因是：对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！
 */
public class Test3  {
    public static void main(String[] args) {
        // 两个对象的Class类模板只有一个，static，锁的是Class
        Phone3 phone1 = new Phone3();
        Phone3 phone2 = new Phone3();

        //锁的存在
        new Thread(()->{
            phone1.sendSms();
        },"A").start();

        // 捕获
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone2.call();
        },"B").start();
    }
}

// Phone3唯一的一个 Class 对象
class Phone3{

    // synchronized 锁的对象是方法的调用者！
    // static 静态方法
    // 类一加载就有了！锁的是Class
    public static synchronized void sendSms(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public static synchronized void call(){
        System.out.println("打电话");
    }


}
```



情况7、8说明：

- 锁的对象不同，即不受锁的影响(Class与对象不同)

```java
/**
 * 7、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？  打电话
 	答案是：先打电话，后发短信了。
	因为一个锁的是Class类模板，一个锁的是对象调用者。后面那个打电话不需要等待发短信，直接运行就可以了。
 * 8、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？  打电话
 	答案是：先打电话、后发短信！
	因为两个对象，一样的原因：两把锁锁的不是同一个东西，所以后面的第二个对象不需要等待第一个对象的执行。
 */
public class Test4  {
    public static void main(String[] args) {
        // 两个对象的Class类模板只有一个，static，锁的是Class
        Phone4 phone1 = new Phone4();
        Phone4 phone2 = new Phone4();
        //锁的存在
        new Thread(()->{
            phone1.sendSms();
        },"A").start();

        // 捕获
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone2.call();
        },"B").start();
    }
}

// Phone3唯一的一个 Class 对象
class Phone4{

    // 静态的同步方法 锁的是 Class 类模板
    public static synchronized void sendSms(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    // 普通的同步方法  锁的调用者
    public synchronized void call(){
        System.out.println("打电话");
    }

}
```



## 线程不安全集合

### List不安全

#### 测试list不安全

```java
//java.util.ConcurrentModificationException 并发修改异常！
public class ListTest {
    public static void main(String[] args) {

        List<Object> arrayList = new ArrayList<>();

        for(int i=1;i<=10;i++){
            new Thread(()->{
                arrayList.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(arrayList);
            },String.valueOf(i)).start();
        }

    }
}
```

会造成==ConcurrentModificationException 并发修改异常==！

![image-20200813091719960](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813091719960.png)

**ArrayList 在并发情况下是不安全的！**

#### 解决方案1：使用Vector

源码分析Vector的add方法：

```java
/**
  * Vector add()
  */
public synchronized void insertElementAt(E obj, int index) {
    modCount++;
    if (index > elementCount) {
        throw new ArrayIndexOutOfBoundsException(index
                                                 + " > " + elementCount);
    }
    ensureCapacityHelper(elementCount + 1);
    System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
    elementData[index] = obj;
    elementCount++;
}
```

**Vector**底层是使用==**synchronized**==关键字来实现的：效率特别低下。

**Vector(jdk1.0)比ArrayList(jdk1.2)出现的早**,由此可看Vector的性能确实存在一些问题。



#### 解决方案2：使用synchronizedList

synchronizedList底层也是是使用==**synchronized**==关键字来实现的：效率特别低下。

![image-20200813092320872](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813092320872.png)

#### 解决方案3：使用CopyOnWriteArrayList

**CopyOnWriteArrayList**：写入时复制！ **COW 计算机程序设计领域的一种优化策略**

多个线程调用的时候，list，读取的时候，固定的，写入(存在覆盖操作)；在写入的时候避免覆盖，造成数据错乱的问题；

```java
/**
  * CopyOnWriteArrayList add()
  */
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

**CopyOnWriteArrayList**使用的是Lock锁，效率会更加高效！



#### 总结

```java
public class ListTest {
    public static void main(String[] args) {
        // 并发下 ArrayList 不安全的吗，Synchronized；
        /**
         * 解决方案；
         * 1、List<String> list = new Vector<>();
         * 2、List<String> list = Collections.synchronizedList(new ArrayList<>());
         * 3、List<String> list = new CopyOnWriteArrayList<>()；
         */
        List<String> list = new CopyOnWriteArrayList<>();

        for (int i = 1; i <= 10; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(list);
            },String.valueOf(i)).start();
        }

    }
}
```



### Set不安全

**Set和List同理可得:** 多线程情况下，普通的Set集合是线程不安全的；

#### 解决方案

- 使用Collections工具类的**synchronized**包装的Set类
- 使用CopyOnWriteArraySet 写入复制的**JUC**解决方案

```java
public class SetTest {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        // hashmap
        // Set<String> set = Collections.synchronizedSet(new HashSet<>());
        // Set<String> set = new CopyOnWriteArraySet<>();

        for (int i = 1; i <=30 ; i++) {
           new Thread(()->{
               set.add(UUID.randomUUID().toString().substring(0,5));
               System.out.println(set);
           },String.valueOf(i)).start();
        }

    }
}
```

#### HashSet底层是什么？

hashSet底层就是一个**HashMap**：

```java
public HashSet() {
        map = new HashMap<>();
}

//add 本质其实就是一个map的key，map的key是无法重复的，所以使用的就是map存储
//hashSet就是使用了hashmap key不能重复的原理
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
//PRESENT是什么？ 是一个常量  不会改变的常量  无用的占位
private static final Object PRESENT = new Object();
```



### Map不安全

#### Map的基本操作

```java
//map 是这样用的吗？  不是，工作中不使用这个
//默认等价什么？ new HashMap<>(16,0.75);
Map<String, String> map = new HashMap<>();
//加载因子、初始化容量
```

默认**加载因子是0.75**,默认的**初始容量是16**

```java
/**
* The default initial capacity - MUST be a power of two.
*/
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

/**
* The load factor used when none specified in constructor.
*/
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

同样的HashMap基础类也存在**并发修改异常**！

```java
public static void main(String[] args) {
        //map 是这样用的吗？  不是，工作中不使用这个
        //默认等价什么？ new HashMap<>(16,0.75);
        Map<String, String> map = new HashMap<>();
        //加载因子、初始化容量
        for (int i = 1; i < 100; i++) {
            new Thread(()->{
                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(0,5));
                System.out.println(map);
            },String.valueOf(i)).start();
        }
    }
```

结果同样的出现了：**异常java.util.ConcurrentModificationException 并发修改异常**

#### 解決方案

- **使用Collections.synchronizedMap(new HashMap<>());处理**；
- **使用ConcurrentHashMap进行并发处理**

#### 研究ConcurrentHashMap底层原理：



## Callable

```java
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```



jdk介绍：

```java
@FunctionalInterface
public interface Callable<V>返回结果并可能引发异常的任务。 实现者定义一个没有参数的单一方法，称为call 。 
Callable接口类似于Runnable ，因为它们都是为其实例可能由另一个线程执行的类设计的。 然而，A Runnable不返回结果，也不能抛出被检查的异常。 

该Executors类包含的实用方法，从其他普通形式转换为Callable类。 

从以下版本开始： 
1.5 
```



### 使用分析

Calleable 泛型T就是**call运行方法的返回值类型**；但是**如何使用**呢？**Callable怎么放入到Thread里面呢？**

```java
public Thread(Runnable target, String name) {
    init(null, target, name, 0);
}
```

对于Thread运行，只能传入Runnable类型的参数；我们这是Callable 怎么办呢？看JDK api文档：在Runnable里面有一个叫做FutureTask的实现类

![image-20200813095238672](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813095238672.png)

这样我们就可以先把Callable 放入到FutureTask中， 然后再把FutureTask 放入到Thread就可以了。



#### 使用流程

1. 创建一个实现`Callable`的实现类
2. `实现call`方法，将此线程需要执行的操作声明在`call()`中
3. 创建`Callable接口实现类`的对象
4. 将此`Callable接口实现类`的对象作为传递到`FutureTask构造器`中，创建`FutureTask的对象`
5. 将`FutureTask的对象`作为参数传递到`Thread类的构造器`中，创建`Thread对象`，并调用`start()`
6. 获取`Callable`中`call方法`的返回值，`get()返回值`即为`FutureTask构造器参数`，`Callable实现类`重写的`call()`的返回值。

#### 对比实现Runnable方式

- 相比run()方法，可以有返回值

- 方法可以抛出异常

- 支持泛型的返回值

- 需要借助`FutureTask`类，比如获取返回结果

  

#### Future接口

- 可以对具体`Runnable`、 `Callable`任务的执行结果进行取消、查询是否完成、获取结果等。
- `FutrueTask`是`Futrue接口`的唯一的实现类
- `FutureTask `同时实现了`Runnable`, `Future接`口。它既可以作为`Runnable`被线程执行，又可以作为`Future`得到`Callable`的返回值
- `get()`可以得到执行的泛型返回值



#### 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？

1. call()可以有返回值的。

2. call()可以抛出异常，被外面的操作捕获，获取异常的信息

3. Callable是支持泛型的

#### 示例

```java
//1.创建一个实现Callable的实现类
class NumThread implements Callable{
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}

public class ThreadNew {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();

        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
            Object sum = futureTask.get();
            System.out.println("总和为：" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

}
```



## 常用的辅助类

### CountDownLatch

![image-20200813100032673](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813100032673.png)

**其实就是一个减法计数器，对于计数器归零之后再进行后面的操作，这是一个计数器！**

```java
// 计数器
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        // 总数是6，必须要执行任务的时候，再使用！
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 1; i <=6 ; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+" Go out");
                countDownLatch.countDown(); // 数量-1
            },String.valueOf(i)).start();
        }

        countDownLatch.await(); // 等待计数器归零，然后再向下执行

        System.out.println("Close Door");

    }
}
```

主要方法：

- countDown 减一操作；
- await 等待计数器归零。

await等待计数器为0，就唤醒，再继续向下运行。



### CyclickBarrier

![image-20200813100337278](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813100337278.png)

**其实就是一个加法计数器**

```java
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        /**
         * 集齐7颗龙珠召唤神龙
         */
        // 召唤龙珠的线程
        CyclicBarrier cyclicBarrier = new CyclicBarrier(8,()->{
            System.out.println("召唤神龙成功！");
        });

        for (int i = 1; i <=7 ; i++) {
            final int temp = i;
            // lambda能操作到 i 吗
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"收集"+temp+"个龙珠");
                try {
                    cyclicBarrier.await(); // 等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }

    }
}
```



### Semaphore(信号量)

```java
public class SemaphoreDemo {
    public static void main(String[] args) {
        // 线程数量：停车位! 限流！
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i <=6 ; i++) {
            new Thread(()->{
                // acquire() 得到
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"抢到车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName()+"离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // release() 释放
                }

            },String.valueOf(i)).start();
        }

    }
}
```

原理：

**semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！**

**semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！**

作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！



## 阻塞队列

 ![image-20200813105500085](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813105500085.png)



![image-20200813105535341](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813105535341.png)

![image-20200813105631762](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813105631762.png)



![image-20200813105656214](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200813105656214.png)

什么情况下我们会使用 阻塞队列：多线程并发处理，线程池！

### BlockingQueue

**四组API**

| 方式       | 抛出异常 | 不会抛出异常，有返回值 | 阻塞 等待 | 超时 等待                |
| ---------- | -------- | ---------------------- | --------- | ------------------------ |
| 添加       | add      | offer                  | put       | offer(timenum，timeUnit) |
| 移除       | remove   | poll                   | take      | poll(timenum，timeUnit)  |
| 判断队列首 | element  | peek                   | -         | -                        |

```java
	/**
     * 抛出异常
     */
    public static void test1(){
        //需要初始化队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("b"));
        System.out.println(blockingQueue.add("c"));
        //抛出异常：java.lang.IllegalStateException: Queue full
//        System.out.println(blockingQueue.add("d"));
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        //如果多移除一个
        //这也会造成 java.util.NoSuchElementException 抛出异常
        System.out.println(blockingQueue.remove());
    }
=======================================================================================
	/**
     * 不抛出异常，有返回值
     */
    public static void test2(){
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
        //添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常
        System.out.println(blockingQueue.offer("d"));

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        //弹出 如果没有元素 只会返回null 不会抛出异常
        System.out.println(blockingQueue.poll());
    }
=======================================================================================
	/**
     * 等待 一直阻塞
     */
    public static void test3() throws InterruptedException {
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

        //一直阻塞 不会返回
        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");

        //如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止
//        blockingQueue.put("d");

        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        //如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞
        System.out.println(blockingQueue.take());
    }
=======================================================================================
	/**
     * 等待 超时阻塞
     *  这种情况也会等待队列有位置 或者有产品 但是会超时结束
     */
    public static void test4() throws InterruptedException {
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
        blockingQueue.offer("a");
        blockingQueue.offer("b");
        blockingQueue.offer("c");
        System.out.println("开始等待");
        blockingQueue.offer("d",2, TimeUnit.SECONDS);  //超时时间2s 等待如果超过2s就结束等待
        System.out.println("结束等待");
        System.out.println("===========取值==================");
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println("开始等待");
        blockingQueue.poll(2,TimeUnit.SECONDS); //超过两秒 我们就不要等待了
        System.out.println("结束等待");
    }
```



### SynchronousQueue同步队列

同步队列 没有容量，也可以视为**容量为1的队列**；

进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；

**put**方法 和 **take**方法；

**Synchronized** 和 其他的**BlockingQueue** 不一样 它不存储元素；

put了一个元素，就必须从里面先take出来，否则不能再put进去值！

并且SynchronousQueue 的take是使用了**lock锁保证线程安全**的。

```java
/**
 * 同步队列
 */
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> synchronousQueue = new SynchronousQueue<>();
        //研究一下 如果判断这是一个同步队列

        //使用两个进程
        // 一个进程 放进去
        // 一个进程 拿出来
        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+" Put 1");
                synchronousQueue.put("1");
                System.out.println(Thread.currentThread().getName()+" Put 2");
                synchronousQueue.put("2");
                System.out.println(Thread.currentThread().getName()+" Put 3");
                synchronousQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"T1").start();

        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+" Take "+synchronousQueue.take());
//                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+" Take "+synchronousQueue.take());
//                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+" Take "+synchronousQueue.take());

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"T2").start();
    }
}
```



## ForkJoin

### 什么是ForkJoin？

ForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！

大数据中：**MapReduce 核心思想->把大任务拆分为小任务！**

![image-20200814092319548](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814092319548.png)

### ForkJoin的原理特点

实现原理是：**双端队列**！从上面和下面都可以去拿到任务进行执行！

![image-20200814092422487](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814092422487.png)

### 如何使用ForkJoin?

1. 通过**ForkJoinPool**来执行

2. 计算任务 **execute(ForkJoinTask<?> task)**

![image-20200814092608886](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814092608886.png)

3. 计算类要去继承ForkJoinTask；

   ```java
   /**
    * 求和计算的任务！
    * 3000   6000(ForkJoin)  9000(Stream并行流)
    * // 如何使用 forkjoin
    * // 1、forkjoinPool 通过它来执行
    * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task)
    * // 3. 计算类要继承 ForkJoinTask
    */
   public class ForkJoinDemo extends RecursiveTask<Long> {
   
       private Long start;  // 1
       private Long end;    // 1990900000
   
       // 临界值
       private Long temp = 10000L;
   
       public ForkJoinDemo(Long start, Long end) {
           this.start = start;
           this.end = end;
       }
   
       // 计算方法
       @Override
       protected Long compute() {
           if ((end-start)<temp){
               Long sum = 0L;
               for (Long i = start; i <= end; i++) {
                   sum += i;
               }
               return sum;
           }else { // forkjoin 递归
               long middle = (start + end) / 2; // 中间值
               ForkJoinDemo task1 = new ForkJoinDemo(start, middle);
               task1.fork(); // 拆分任务，把任务压入线程队列
               ForkJoinDemo task2 = new ForkJoinDemo(middle+1, end);
               task2.fork(); // 拆分任务，把任务压入线程队列
   
               return task1.join() + task2.join();
           }
       }
   }
   ```

   测试类

   ```java
   public class Test {
       public static void main(String[] args) throws ExecutionException, InterruptedException {
           test1(); // 8483
           test2(); // 4824
           test3(); // 294
       }
   
       // 普通程序员
       public static void test1(){
           Long sum = 0L;
           long start = System.currentTimeMillis();
           for (Long i = 1L; i <= 10_0000_0000; i++) {
               sum += i;
           }
           long end = System.currentTimeMillis();
           System.out.println("sum="+sum+" 时间："+(end-start));
       }
   
       // 会使用ForkJoin
       public static void test2() throws ExecutionException, InterruptedException {
           long start = System.currentTimeMillis();
   
           ForkJoinPool forkJoinPool = new ForkJoinPool();
           ForkJoinTask<Long> task = new ForkJoinDemo(0L, 10_0000_0000L);
           ForkJoinTask<Long> submit = forkJoinPool.submit(task);// 提交任务
           Long sum = submit.get();
   
           long end = System.currentTimeMillis();
   
           System.out.println("sum="+sum+" 时间："+(end-start));
       }
   
       public static void test3(){
           long start = System.currentTimeMillis();
           // Stream并行流 ()  (]
           long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum);
           long end = System.currentTimeMillis();
           System.out.println("sum="+"时间："+(end-start));
       }
   
   }
   ```

三种方式执行结果：

```
sum=500000000500000000 时间：8483
sum=500000000500000000 时间：4824
sum=时间：294
```



**.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。**

![image-20200814093004767](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814093004767.png)

**reduce方法的优点：**

![image-20200814093043025](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814093043025.png)



## 异步回调

> Future 设计的初衷：对将来的某个事件结果进行建模！

其实就是前端 --> 发送ajax异步请求给后端

![image-20200814093243806](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814093243806.png)

我们平时都使用**CompletableFuture**

**(1)没有返回值的runAsync异步回调**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException 
{
        // 发起 一个 请求

        System.out.println(System.currentTimeMillis());
        System.out.println("---------------------");
        CompletableFuture<Void> future = CompletableFuture.runAsync(()->{
            //发起一个异步任务
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+".....");
        });
        System.out.println(System.currentTimeMillis());
        System.out.println("------------------------------");
        //输出执行结果
        System.out.println(future.get());  //获取执行结果
 }
```

**(2)有返回值的异步回调supplyAsync**

```java
//有返回值的异步回调
CompletableFuture<Integer> completableFuture=CompletableFuture.supplyAsync(()->{
    System.out.println(Thread.currentThread().getName());
    try {
        TimeUnit.SECONDS.sleep(2);
        int i=1/0;
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return 1024;
});
System.out.println(completableFuture.whenComplete((t, u) -> {
    //success 回调
    System.out.println("t=>" + t); //正常的返回结果
    System.out.println("u=>" + u); //抛出异常的 错误信息
}).exceptionally((e) -> {
    //error回调
    System.out.println(e.getMessage());
    return 404;
}).get());
```

**whenComplete**: 有两个参数，一个是t 一个是u

T：是代表的 **正常返回的结果**；

U：是代表的 **抛出异常的错误信息**；

如果发生了异常，get可以获取到**exceptionally**返回的值；

## JMM

在并发编程中，需要处理两个关键问题：==线程之间如何通信==及==线程之间如何同步==



> 请你谈谈你对Volatile 的理解

**Volatile** 是 Java 虚拟机提供 **轻量级的同步机制**

**1、保证可见性
2、不保证原子性
3、禁止指令重排**

> 什么是JMM？

JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！

**关于JMM的一些同步的约定：**

1、线程解锁前，必须把共享变量**立刻**刷回主存；

2、线程加锁前，必须**读取主存**中的最新值到工作内存中；

3、加锁和解锁是同一把锁；

线程中分为 **工作内存、主内存**

**8种操作**:

- **Read(读取)**：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；
- **load(载入)**：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；
- **Use(使用)**：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；
- **assign(赋值)**：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；
- **store(存储)**：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；
- **write(写入)**：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；
- **lock(锁定)**：作用于主内存的变量，把一个变量标识为线程独占状态；
- **unlock(解锁)**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；

![image-20200814093746851](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814093746851.png)

![image-20200814093811178](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814093811178.png)

**JMM对这8种操作给了相应的规定**：

- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
- 不允许一个线程将没有assign的数据从工作内存同步回主内存
- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作
- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
- 对一个变量进行unlock操作之前，必须把此变量同步回主内存

![image-20200814093845687](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814093845687.png)

## Volatile

> 关键字volatile可以用来修饰字段(成员变量)，就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。

关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。

### 定义与实现原理

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的"可见性"。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为==它不会引起线程上下文的切换和调度==。

Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，Lock前缀的指令在多核处理器下会引发了两件事情。

1)将当前处理器缓存行的数据写回到系统内存。

2)这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

### 实现原则

1. Lock前缀指令会引起处理器缓存回写到内存

2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效



### Volatile的特点

#### 1、保证可见性

```java
public class JMMDemo01 {

    // 如果不加volatile 程序会死循环
    // 加了volatile是可以保证可见性的
    private volatile static Integer number = 0;

    public static void main(String[] args) {
        //main线程
        //子线程1
        new Thread(()->{
            while (number==0){
            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //子线程2
        new Thread(()->{
            while (number==0){
            }

        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        number=1;
        System.out.println(number);
    }
}

```

#### 2、不保证原子性

原子性：不可分割；

线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。

```java
/**
 * 不保证原子性
 * number <=2w
 * 
 */
public class VDemo02 {

    private static volatile int number = 0;

    public static void add(){
        number++; 
        //++ 不是一个原子性操作，是两个~3个操作
        //
    }

    public static void main(String[] args) {
        //理论上number  === 20000

        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 1; j <= 1000 ; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){
            //main  gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+",num="+number);
    }
}

```

执行五次main方法结果：

```
main,num=19052
main,num=20000
main,num=20000
main,num=19722
main,num=20000
```

有一定的概率不能保证数据的正确性

分析：

number++不是一个操作，而是三个操作，所以不能保证原子性：

1. get取到number的值
2. 进行+1操作
3. put写number的值

即理论值应该是20000，但可能达不到

**如果不加lock和synchronized ，怎么样保证原子性？**

解决方法：使用JUC下的java.util.concurrent.atomic包下的class；

![image-20200814095936365](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814095936365.png)

```java
public class VDemo02 {

    private static volatile AtomicInteger number = new AtomicInteger();

    public static void add(){
//        number++;
        number.incrementAndGet();  //底层是CAS保证的原子性
    }

    public static void main(String[] args) {
        //理论上number  === 20000

        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 1; j <= 1000 ; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){
            //main  gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+",num="+number);
    }
}
```

这些类的底层都直接和操作系统挂钩！是在内存中修改值。

Unsafe类是一个很特殊的存在；

![image-20200814100351230](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814100351230.png)

**原子类为什么这么高级？**

#### 3、禁止指令重排

我们写的程序，计算机并不是按照我们自己写的那样去执行的

源代码–>编译器优化重排–>指令并行也可能会重排–>内存系统也会重排–>执行

**处理器在进行指令重排的时候，会考虑数据之间的依赖性！**

```java
int x=1; //1
int y=2; //2
x=x+5;   //3
y=x*x;   //4

//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324
//可不可能是 4123？ 不可能的
1234567
```

可能造成的影响结果：前提：a b x y这四个值 默认都是0

| 线程A | 线程B |
| ----- | ----- |
| x=a   | y=b   |
| b=1   | a=2   |

正常的结果： x = 0; y =0;

| 线程A | 线程B |
| ----- | ----- |
| x=a   | y=b   |
| b=1   | a=2   |

可能在线程A中会出现，先执行b=1,然后再执行x=a；

在B线程中可能会出现，先执行a=2，然后执行y=b；

那么就有可能结果如下：x=2; y=1.

**volatile可以避免指令重排：**

**volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。**

内存屏障：CPU指令。作用：

1、保证特定的操作的执行顺序；

2、可以保证某些变量的内存可见性(利用这些特性，就可以保证volatile实现的可见性)

![image-20200814100613459](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814100613459.png)



**小结：**

- **volatile可以保证可见性；**
- **不能保证原子性**
- **由于内存屏障，可以保证避免指令重排的现象产生**

面试官：那么你知道在哪里用这个内存屏障用得最多呢？**单例模式**

### Volatile优化

JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。LinkedTransferQueue的代码如下：

```java
/** 队列中的头部节点 */
private transient f?inal PaddedAtomicReference<QNode> head;
/** 队列中的尾部节点 */
private transient f?inal PaddedAtomicReference<QNode> tail;
static f?inal class PaddedAtomicReference <T> extends AtomicReference T> {
     // 使用很多4个字节的引用追加到64个字节
     Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
     PaddedAtomicReference(T r) {
        super(r);
     }
}
public class AtomicReference <V> implements java.io.Serializable {
     private volatile V value;
     // 省略其他代码
｝
```

**追加字节如何能优化性能？**

LinkedTransferQueue这个类，它使用一个内部类类型来定义队列的头节点(head)和尾节点(tail)，而这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就是将共享变量追加到64字节。我们可以来计算下，一个对象的引用占4个字节，它追加了15个变量(共占60个字节)，再加上父类的value变量，一共64个字节。

对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，==在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率==。

==使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定==。

**在两种场景下不应该使用volatile变量时追加到64字节**

==缓存行非64字节宽的处理器==。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。

==共享变量不会被频繁地写==。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。



## 原子操作

### 处理器如何实现原子操作

(1)使用总线锁保证原子性

(2)使用缓存锁保证原子性

### Java如何实现原子操作

在Java中可以通过==锁==和==循环CAS==的方式来实现原子操作

#### 循环CAS

从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean(用原子方式更新的boolean值)、AtomicInteger(用原子方式更新的int值)和AtomicLong(用原子方式更新的long值)。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。

以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count：

```java
private AtomicInteger atomicI = new AtomicInteger(0);
    private int i = 0;
    public static void main(String[] args) {
        final Counter cas = new Counter();
        List<Thread> ts = new ArrayList<Thread>(600);
        long start = System.currentTimeMillis();
        for (int j = 0; j < 100; j++) {
            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10000; i++) {
                        cas.count();
                        cas.safeCount();
                    }
                }
            });
            ts.add(t);
        }
        for (Thread t : ts) {
            t.start();
        }
    // 等待所有线程执行完成
        for (Thread t : ts) {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(cas.i);
        System.out.println(cas.atomicI.get());
        System.out.println(System.currentTimeMillis() - start);
    }
    /**        * 使用CAS实现线程安全计数器        */
    private void safeCount() {
        for (;;) {
            int i = atomicI.get();
            boolean suc = atomicI.compareAndSet(i, ++i);
            if (suc) {
                break;
            }
        }
    }
    /**
     * 非线程安全计数器


     */
    private void count() {
        i++;
    }
}
```

#### 使用锁机制实现原子操作

锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。



## 深入理解CAS

### 什么是CAS？

大厂必须深入研究底层！！！！**修内功！操作系统、计算机网络原理、组成原理、数据结构**

```java
public class casDemo {
    //CAS : compareAndSet 比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        //boolean compareAndSet(int expect, int update)
        //期望值、更新值
        //如果实际值 和 我的期望值相同，那么就更新
        //如果实际值 和 我的期望值不同，那么就不更新
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        //因为期望值是2020  实际值却变成了2021  所以会修改失败
        //CAS 是CPU的并发原语
        atomicInteger.getAndIncrement(); //++操作
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}
```

**源码分析：**

AtomicInteger的getAndIncrement()

```java
/**
* Atomically increments by one the current value.
*
* @return the previous value
*/
public final int getAndIncrement() {
	return unsafe.getAndAddInt(this, valueOffset, 1);
}
```

Unsafe的getAndAddInt

使用了compareAndSwapInt==自旋锁==

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

compareAndSwapInt：

```java
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

![image-20200814101650846](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814101650846.png)

![image-20200814101719291](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814101719291.png)

**总结：**

CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。

**缺点：**

- 循环会耗时；
- 一次性只能保证一个共享变量的原子性；
- 它会存在ABA问题

### CAS问题

#### 1.循环时间长开销大。

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

#### 2.只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。



#### 3.ABA问题？(狸猫换太子)

因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。

ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A=>B=>A就会变成1A=>2B=>3A。

Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

![image-20200814101850855](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814101850855.png)

线程1：期望值是1，要变成2；

线程2：两个操作：

- 1、期望值是1，变成3
- 2、期望是3，变成1

所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；

示例：

```java
public class casDemo {
    //CAS : compareAndSet 比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        //boolean compareAndSet(int expect, int update)
        //期望值、更新值
        //如果实际值 和 我的期望值相同，那么就更新
        //如果实际值 和 我的期望值不同，那么就不更新
        System.out.println(atomicInteger.compareAndSet(2021, 2020));
        System.out.println(atomicInteger.get());

        //因为期望值是2020  实际值却变成了2021  所以会修改失败
        //CAS 是CPU的并发原语
//        atomicInteger.getAndIncrement(); //++操作
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}
```





## 原子引用

### 解决ABA问题，对应的思想：就是使用了==乐观锁==

带版本号的 原子操作！

**Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。**

![image-20200814102253204](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814102253204.png)

所以如果遇到，使用大于128的时候，**使用原子引用的时候，如果超过了这个值，那么就不会进行版本上升！**

即：` static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(2020,1);`，则使用会出现问题。

正常业务操作中，我们一般使用的是一个个对象，一般情况不会遇到这种情况。

```java
public class CASDemo {

    //AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题

    // 正常在业务操作，这里面比较的都是一个个对象
    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1,1);

    // CAS  compareAndSet : 比较并交换！
    public static void main(String[] args) {
        new Thread(()->{
            int stamp = atomicStampedReference.getStamp(); // 获得版本号
            System.out.println("a1=>"+stamp);

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            Lock lock = new ReentrantLock(true);

            atomicStampedReference.compareAndSet(1, 2,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);

            System.out.println("a2=>"+atomicStampedReference.getStamp());


            System.out.println(atomicStampedReference.compareAndSet(2, 1,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));

            System.out.println("a3=>"+atomicStampedReference.getStamp());

        },"a").start();


        // 乐观锁的原理相同！
        new Thread(()->{
            int stamp = atomicStampedReference.getStamp(); // 获得版本号
            System.out.println("b1=>"+stamp);

            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(atomicStampedReference.compareAndSet(1, 6,
                    stamp, stamp + 1));

            System.out.println("b2=>"+atomicStampedReference.getStamp());

        },"b").start();

    }
}

```

执行结果

```
a1=>1
b1=>1
a2=>2
true
a3=>3
false
b2=>3
```

b线程的邮票值不对应，则不能进行修改。



## 各种锁的理解

### 1、公平锁、非公平锁

**公平锁**：非常公平；不能插队的，必须先来后到；

```java
/**
 * Creates an instance of {@code ReentrantLock}.
 * This is equivalent to using {@code ReentrantLock(false)}.
 */
public ReentrantLock() {
    sync = new NonfairSync();
}
```

**非公平锁**：非常不公平，允许插队的，可以改变顺序。

```java
/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

### 2、可重入锁

可重入锁(递归锁)

![image-20200814111337962](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814111337962.png)

> Synchronized锁

```java
public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(()->{
            phone.sms();
        },"A").start();
        new Thread(()->{
            phone.sms();
        },"B").start();
    }

}

class Phone{
    public synchronized void sms(){
        System.out.println(Thread.currentThread().getName()+"=> sms");
        call();//这里也有一把锁
    }
    public synchronized void call(){
        System.out.println(Thread.currentThread().getName()+"=> call");
    }
}
```

> lock锁

```java
//lock
public class Demo02 {

    public static void main(String[] args) {
        Phone2 phone = new Phone2();
        new Thread(()->{
            phone.sms();
        },"A").start();
        new Thread(()->{
            phone.sms();
        },"B").start();
    }

}
class Phone2{

    Lock lock=new ReentrantLock();

    public void sms(){
        lock.lock(); //细节：这个是两把锁，两个钥匙
        //lock锁必须配对，否则就会死锁在里面
        try {
            System.out.println(Thread.currentThread().getName()+"=> sms");
            call();//这里也有一把锁
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void call(){
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "=> call");
        }catch (Exception e){
            e.printStackTrace();
        }
        finally {
            lock.unlock();
        }
    }
}
```

- lock锁必须配对，相当于lock和 unlock 必须数量相同；
- 在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁；

### 3、自旋锁

spinlock

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    return var5;
}
```

**自我设计自旋锁：**

```java
public class SpinlockDemo {

    //int 0
    //thread null
    AtomicReference<Thread> atomicReference=new AtomicReference<>();

    //加锁
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName()+"===> mylock");

        //自旋锁
        while (!atomicReference.compareAndSet(null,thread)){
            System.out.println(Thread.currentThread().getName()+" ==> 自旋中~");
        }
    }


    //解锁
    public void myunlock(){
        Thread thread=Thread.currentThread();
        System.out.println(thread.getName()+"===> myUnlock");
        atomicReference.compareAndSet(thread,null);
    }

}

public class TestSpinLock {
    public static void main(String[] args) throws InterruptedException {
        ReentrantLock reentrantLock = new ReentrantLock();
        reentrantLock.lock();
        reentrantLock.unlock();


        //使用CAS实现自旋锁
        SpinlockDemo spinlockDemo=new SpinlockDemo();
        new Thread(()->{
            spinlockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                spinlockDemo.myunlock();
            }
        },"t1").start();

        TimeUnit.SECONDS.sleep(1);


        new Thread(()->{
            spinlockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                spinlockDemo.myunlock();
            }
        },"t2").start();
    }
}

```

运行结果：

**t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待。。。。**



* 原理

![image-20230314170608244](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20230314170608244.png)





### 4、死锁

**死锁是什么？**

![image-20200814111731992](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814111731992.png)

死锁测试，怎么排除死锁：

```java
public class DeadLock {
    public static void main(String[] args) {
        String lockA= "lockA";
        String lockB= "lockB";

        new Thread(new MyThread(lockA,lockB),"t1").start();
        new Thread(new MyThread(lockB,lockA),"t2").start();
    }
}

class MyThread implements Runnable{

    private String lockA;
    private String lockB;

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+" lock"+lockA+"===>get"+lockB);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName()+" lock"+lockB+"===>get"+lockA);
            }
        }
    }
}
```

> 解决问题

**1、使用jps定位进程号，jdk的bin目录下： 有一个jps**

命令：`jps -l`

![image-20200814112257872](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814112257872.png)



**2、使用`jstack` 进程进程号 找到死锁信息**

![image-20200814112401945](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814112401945.png)

一般在最后：
![image-20200814112512148](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814112512148.png)

**面试，工作中！排查问题！**

**1、日志**

**2、堆栈信息**



#### **如何避免死锁？**

1. 避免一个线程同时获取多个锁。
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。



### 5.无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态

在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率

![image-20200819210526187](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200819210526187.png)



# 并发编程的艺术

## 并发编程的挑战

并发编程的目的是==为了让程序运行得更快==。

并发编程的挑战，即在并发编程中遇到的那些问题，会影响程序运行的更快。

### 1. 上下文切换问题

> 即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒(ms)。
>
> CPU通过==时间片分配算法==来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。

==上下文切换也会影响多线程的执行速度==。*就像单词不认识，必须放下技术书去查单词，还必须记住书读到了哪一页，以便查完单词，重新读这本书。*



多线程并发执行，并不一定比串行执行的快！！！

当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。那么，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。

**如何减少上下文切换？**

1. ==无锁并发编程==。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。

2. ==CAS算法==。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。

3. ==使用最少线程==。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。

4. ==协程==：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。



### 2.死锁问题

详情参看上文：   [死锁](#4、死锁)



### 3. 资源限制的问题

> 资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源

例如，服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10Mb/s，所以在进行并发编程时，要考虑这些资源的限制。

在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为==增加了上下文切换和资源调度的时间==



**如何解决资源限制的问题？**

对于硬件资源限制，可以考虑使用集群并行执行程序

对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接。



**如何在资源限制的情况下，让程序执行得更快呢？**

方法就是，根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作
时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。



多使用JDK并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化，均可解决了提到的几个挑战。





# synchronized

## 1. 什么是synchronized？

> **`synchronized` 关键字解决的是多个线程之间访问资源的同步性，`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。**

## 2. 怎么使用 synchronized 关键字？

**synchronized 锁的是什么？**

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步代码块，锁是Synchonized括号里配置的对象。

**synchronized 关键字最主要的三种使用方式：**

**1.修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

```java
synchronized void method() {
  //业务代码
}
```

**2.修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 Class对象 的锁**。因为静态成员不属于任何一个实例对象，是类成员( _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_)。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

```java
synchronized static void method() {
//业务代码
}
```

**3.修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 Class对象 的锁**

```java
synchronized(this) {
  //业务代码
}
```

**总结：**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到实例方法上是给对象实例上锁。
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能！

下面我以一个常见的面试题为例讲解一下 `synchronized` 关键字的具体使用。

面试中面试官经常会说："单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！"

**双重校验锁实现对象单例(线程安全)**

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

另外，需要注意 `uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要。

`uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

1. 为 `uniqueInstance` 分配内存空间
2. 初始化 `uniqueInstance`
3. 将 `uniqueInstance` 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 `getUniqueInstance`() 后发现 `uniqueInstance` 不为空，因此返回 `uniqueInstance`，但此时 `uniqueInstance` 还未被初始化。

使用 `volatile` 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

## 3. 构造方法可以使用 synchronized 关键字修饰么？

**构造方法不能使用 synchronized 关键字修饰。**

构造方法本身就属于线程安全的，不存在同步的构造方法一说。

## 4.  synchronized 关键字的底层原理

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？

**synchronized 关键字底层原理属于 JVM 层面。**



### 4.1 synchronized 同步语句块的情况

```java
public class SynchronizedDemo {
    public void method() {
        synchronized (this) {
            System.out.println("synchronized 代码块");
        }
    }
}
```

通过 JDK 自带的 `javap` 命令查看 `SynchronizedDemo` 类的相关字节码信息：首先切换到类的对应目录执行 `javac SynchronizedDemo.java` 命令生成编译后的 .class 文件，然后执行`javap -c -s -v -l SynchronizedDemo.class`。

<img src="images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/SynchronizedDemo%E7%9A%84jvm%E6%83%85%E5%86%B5.png" alt="image-20210614165327757"  />

从上面我们可以看出：

**`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置/异常位置。**

当执行 `monitorenter` 指令时，线程试图获取锁也就是获取 **对象监视器 `monitor`** 的持有权。

> 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由[ObjectMonitor](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp)实现的。每个对象中都内置了一个 `ObjectMonitor`对象。
>
> 另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。

在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。.

### 4.2 synchronized 修饰方法的的情况

```java
public class SynchronizedDemo2 {
    public synchronized void method() {
        System.out.println("synchronized 方法");
    }
}
```

![image-20210614165617408](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/synchronized%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86.png)



`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

### 4.3 总结

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**

## 5 JDK1.6 之后的 synchronized 关键字底层做了哪些优化？

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

关于这几种优化的详细信息可以查看下面这篇文章：[Java6 及以上版本对 synchronized 的优化](https://www.cnblogs.com/wuqinglong/p/9945618.html)

## 6 synchronized 和 ReentrantLock 的区别

### 6.1 两者都是可重入锁

**"可重入锁"** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。

### 6.2 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

`synchronized` 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 `synchronized` 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。`ReentrantLock` 是 JDK 层面实现的(也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成)，所以我们可以通过查看它的源代码，来看它是如何实现的。

### 6.3 ReentrantLock 比 synchronized 增加了一些高级功能

相比`synchronized`，`ReentrantLock`增加了一些高级功能。主要来说主要有三点：

- **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
- **可实现选择性通知(锁可以绑定多个条件)**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。

> `Condition`是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个`Lock`对象中可以创建多个`Condition`实例(即对象监视器)，**线程对象可以注册在指定的`Condition`中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用`notify()/notifyAll()`方法进行通知时，被通知的线程是由 JVM 选择的，用`ReentrantLock`类结合`Condition`实例可以实现"选择性通知"** ，这个功能非常重要，而且是 Condition 接口默认提供的。而`synchronized`关键字就相当于整个 Lock 对象中只有一个`Condition`实例，所有的线程都注册在它一个身上。如果执行`notifyAll()`方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而`Condition`实例的`signalAll()`方法 只会唤醒注册在该`Condition`实例中的所有等待线程。

**如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准**

## 7. synchronized与对象头

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，则用2字宽存储对象头。

Java对象头的长度：

![Java对象头的长度](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110011130581.png)

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。

Java对象头的存储结构：

![Java对象头的存储结构](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110011131420.png)

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：

32位Mark Word的状态变化：

![32位Mark Word的状态变化](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110011132836.png)

在64位虚拟机下，Mark Word是64bit大小的，其存储结构如表：

![64位 Mark Word的存储结构](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110011133698.png)

## 8 synchronized的锁升级过程

锁升级过程依次为：无锁状态、偏向锁、轻量级锁、重量级锁。

synchronized可以进行锁升级，但是不能降级，目的是**为了提高获得锁和释放锁的效率**。

### 8.1 偏向锁

> HotSpot作者发现，大多数情况下，**锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁**。

**对象头**：

- 23bit的线程ID；
- 1bit是否为偏向锁值为1说明是偏向锁状态；
- 无锁和偏向锁2bit的锁标志位都是01

**偏向锁加锁过程**：

1. 检查对象头和栈帧中的锁记录是否存储了当前线程的线程ID  
   1. 即简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁即可
   2. *(为了保证当前线程每次进入和退出同步块时不需要CAS操作加锁和解锁)*
2. 测试成功表示获得了锁
3. 测试失败再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁)
   1. 如果没有设置，则使用CAS竞争锁
   2. 如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程

**偏向锁撤销过程**：

偏向锁使用了一种**等到竞争出现才释放锁**的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

1. 前提条件：等待全局安全点(在这个时间点上没有正在执行的字节码)
2. 暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着
3. 如果线程不处于活动状态，则将对象头设置成无锁状态
4. 如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁
5. 最后唤醒暂停的线程

**偏向锁获得和撤销锁的过程：**

![偏向锁获得和撤销锁的过程](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110011056649.png)

**偏向锁的升级：**

**只要存在两个线程的并发竞争，偏向锁升级为轻量级锁**。



### 8.2 轻量级锁

**轻量级锁加锁过程：**

1. 线程在执行同步块前，JVM在当前线程栈帧中分配空间，并将对象头中的Mark Word复制到锁记录中(官方称为Displaced Mark Word)
2. CAS将对象头中的Mark Word替换为指向锁记录的指针
3. 如果成功，当前线程获得锁
4. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

**轻量级锁撤销过程：**

1. CAS操作将Displaced Mark Word替换回到对象头
2. 如果成功，则表示没有竞争发生
3. 如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁

**轻量级锁膨胀的流程图**：

![轻量级锁膨胀的流程图](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110011116663.png)

### 8.3 重量级锁

因为**自旋会消耗CPU**，为了**避免无用的自旋**(比如获得锁的线程被阻塞住了)，一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。

**当锁处于重量级锁状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争**。

### 8.4 锁的优缺点对比

![synchronized锁的优缺点对比](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110011118990.png)



#### 锁升级

##### 升级过程

**synchronized 是可重入、不公平的重量级锁**，所以可以对其进行优化

```java
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁	// 随着竞争的增加，只能锁升级，不能降级
```

![](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png)



***



##### 偏向锁

偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：

* 当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时**使用 CAS 操作将线程 ID 记录到 Mark Word**。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作

* 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态

<img src="images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png" style="zoom: 67%;" />

一个对象创建时：

* 如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0
* 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 `-XX:BiasedLockingStartupDelay=0` 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低

* 当一个对象已经计算过 hashCode，就再也无法进入偏向状态了
* 添加 VM 参数 `-XX:-UseBiasedLocking` 禁用偏向锁

撤销偏向锁的状态：

* 调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销
* 当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁
* 调用 wait/notify，需要申请 Monitor，进入 WaitSet

**批量撤销**：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID

* 批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程

* 批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的



***



##### 轻量级锁

一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）

可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是**避免死锁**

轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化

锁重入实例：

```java
static final Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块 A
        method2();
    }
}
public static void method2() {
    synchronized( obj ) {
    	// 同步块 B
    }
}
```

* 创建锁记录（Lock Record）对象，每个线程的**栈帧**都会包含一个锁记录的结构，存储锁定对象的 Mark Word

  ![](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png)

* 让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录

* 如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁
  ![](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png)

* 如果 CAS 失败，有两种情况：

  * 如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程
  * 如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数

  ![](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png)

* 当退出 synchronized 代码块（解锁时）

  * 如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1
  * 如果锁记录的值不为 null，这时使用 CAS **将 Mark Word 的值恢复给对象头**
    * 成功，则解锁成功
    * 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程



***



##### 锁膨胀

在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为**重量级锁**

* 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁

  ![](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png)

* Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，**通过 Object 对象头获取到持锁线程**，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED

  ![](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png)

* 当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程





# Volatile

## 1. 相关概念

### 1.1 CPU缓存模型

#### 1.1.1 为什么要有CPU高速缓存？

**CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题**。

就像我们平时使用的缓存(redis)，是为了解决程序处理速度和访问关系型数据库速度不对等的问题。

也可以类比外存，**内存可以看作外存的高速缓存** ，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。

**总结**：

**CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。**

#### 1.1.2 CPU高速缓存的工作方式

![CPU缓存模型](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1623987055.png)

先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。

但是，这样存在 **内存缓存不一致性的问题** ！比如执行一个 i++操作的话，两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。

**CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。**

### 1.2 CPU的术语定义

![CPU的术语定义](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110122108366.png)

### 1.3 JMM(Java内存模型)

> JMM(Java 内存模型 Java Memory Model，简称 JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(实例字段，静态字段和构成数组对象的元素)的访问方式。

在 JDK1.2 之前，Java 的内存模型实现总是从**主存** (即共享内存)读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存**本地内存** (比如机器的寄存器)中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致** 。

![使用volatile前变量读取](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1624000135.png)

要解决这个问题，就需要把变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**

![使用volatile后变量读取](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1624000201.png)

JMM 关于同步的规定：

1. 线程解锁前，必须把共享变量的值刷新回主内存。
2. 线程加锁前，必须读取主内存的最新值到自己的工作内存。
3. 加锁解锁是同一把锁。

**JMM 可以保证：可见性、原子性、有序性**。

### 1.4 并发编程的三个重要特性

1. 原子性：一个或者多次操作，要么全部都执行，不会收到任何因素的干扰而中断；要么全部都不执行。
2. 可见性：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。
3. 有序性：代码在执行的过程当中先后有序。Java在编译器及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。



## 2. `volatile`关键字

### 2.1 `volatile`的定义

> 关键字volatile可以用来修饰字段(成员变量)，就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。

而关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。

### 2.2 实现原理

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的"可见性"。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为[font color="red"]它不会引起线程上下文的切换和调度[/font]。

有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，Lock前缀的指令在多核处理器下会引发了两件事情。

1. **将当前处理器缓存行的数据写回到系统内存**。
2. **这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效**。

所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

### 2.3 `volatile`的特点

#### 2.3.1 保证可见性

```java
public class JMMDemo01 {

    // 如果不加volatile 程序会死循环
    // 加了volatile是可以保证可见性的
    private volatile static Integer number = 0;

    public static void main(String[] args) {
        //main线程
        //子线程1
        new Thread(()->{
            while (number==0){
            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //子线程2
        new Thread(()->{
            while (number==0){
            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        number=1;
        System.out.println(number);
    }
}
```

#### 2.3.2 不保证原子性

```java
/**
 * 不保证原子性
 * number <=2w
 * 
 */
public class VDemo02 {

    private static volatile int number = 0;

    public static void add(){
        number++; 
        //++ 不是一个原子性操作，是两个~3个操作
        //
    }

    public static void main(String[] args) {
        //理论上number  === 20000

        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 1; j <= 1000 ; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){
            //main  gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+",num="+number);
    }
}
```

**执行五次main方法结果：**

```
main,num=19052
 main,num=20000
 main,num=20000
 main,num=19722
 main,num=20000
```

number++不是一个操作，而是三个操作，所以不能保证原子性：

1. get取到number的值
2. 进行+1操作
3. put写number的值

即理论值应该是20000，但可能达不到。有一定的概率不能保证数据的正确性。

**如果不加lock和synchronized ，怎么样保证原子性？**

解决方法：使用JUC下的java.util.concurrent.atomic包下的class；即使用原子类。

![原子类的位置](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814095936365-167687334509114.png)

使用原子类后的操作：

```java
public class VDemo02 {

    private static volatile AtomicInteger number = new AtomicInteger();

    public static void add(){
//        number++;
        number.incrementAndGet();  //底层是CAS保证的原子性
    }

    public static void main(String[] args) {
        //理论上number  === 20000

        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 1; j <= 1000 ; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){
            //main  gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+",num="+number);
    }
}
```

这些类的底层都直接和操作系统挂钩！是在内存中修改值。

Unsafe类是一个很特殊的存在。

![image-20200814100351230](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814100351230-167687334509116.png)

#### 2.3.3 禁止指令重排(有序性)

我们写的程序，计算机并不是按照我们自己写的那样去执行的

源代码–>编译器优化重排–>指令并行也可能会重排–>内存系统也会重排–>执行

**处理器在进行指令重排的时候，会考虑数据之间的依赖性！**

```java
int x=1; //1
int y=2; //2
x=x+5;   //3
y=x*x;   //4

//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324
//可不可能是 4123？ 不可能的
1234567
```

可能造成的影响结果：

前提：a b x y这四个值 默认都是0

| 线程A | 线程B |
| ----- | ----- |
| x=a   | y=b   |
| b=1   | a=2   |

正常的结果： x = 0; y =0;

| 线程A | 线程B |
| ----- | ----- |
| x=a   | y=b   |
| b=1   | a=2   |

可能在线程A中会出现，先执行b=1,然后再执行x=a；

在B线程中可能会出现，先执行a=2，然后执行y=b；

那么就有可能结果如下：x=2; y=1.

**volatile可以避免指令重排：**

**volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。**

内存屏障：CPU指令。作用：

1、保证特定的操作的执行顺序；

2、可以保证某些变量的内存可见性(利用这些特性，就可以保证volatile实现的可见性)

![内存屏障](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/image-20200814100613459-167687334509118.png)

## 3. `volatile`优化

JDK 7的并发包里新增一个队列集合类 `LinkedTransferQueue` ，它在使用 `volatile` 变量时，用一种追加字节的方式来优化队列出队和入队的性能。LinkedTransferQueue的代码如下：

```java
/** 队列中的头部节点 */
private transient f?inal PaddedAtomicReference<QNode> head;
/** 队列中的尾部节点 */
private transient f?inal PaddedAtomicReference<QNode> tail;
static f?inal class PaddedAtomicReference <T> extends AtomicReference T> {
     // 使用很多4个字节的引用追加到64个字节
     Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
     PaddedAtomicReference(T r) {
        super(r);
     }
}
public class AtomicReference <V> implements java.io.Serializable {
     private volatile V value;
     // 省略其他代码
｝
```

**追加字节如何能优化性能？**

`LinkedTransferQueue ` 这个类，它使用一个内部类类型来定义队列的头节点(head)和尾节点(tail)，而这个内部类`PaddedAtomicReference`相对于父类`AtomicReference`只做了一件事情，就是**将共享变量追加到64字节**。我们可以来计算下，一个对象的引用占4个字节，它追加了15个变量(共占60个字节)，再加上父类的value变量，一共64个字节。

对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，**在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率**。

**使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定**。

**在两种场景下不应该使用volatile变量时追加到64字节**

[font color="red"]缓存行非64字节宽的处理器[/font]。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。

[font color="red"]共享变量不会被频繁地写[/font]。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。





## 什么是volatile？

> 《Java语言规范第3版》中对volatile的定义如下：
>
> Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

`volatile`是轻量级的`synchronized`，它在多处理器开发中保证了共享变量的"可见性"，禁止JVM的指令重排，但是不能保证原子性。

`volatile`比`synchronized`的使用和执行成本更低，因为它**不会引起线程上下文的切换和调度**。



## volatile的特性

可见性：对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。

原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。





## volatile 的实现原理？

### 可见性原理

有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，Lock前缀的指令在多核处理器下会引发了两件事情。

1. **将当前处理器缓存行的数据写回到系统内存**。
2. **这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效**。

具体分析：

**问题1：何时将数据写到内存？**

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2或其他)后再进行操作，但操作完不知道何时会写到内存。

如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock**前缀的指令**，将这个变量所在缓存行的数据写回到系统内存。

**问题2：写到内存后其他线程的缓存数据还是旧的，如何解决？**

但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。

解决策略：

1. 在多处理器下，实现**缓存一致性协议**，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了**，当处理器发现自己缓存行对应的内存地址被修改，就会**将当前处理器的缓存行设置成无效状态**。
2. 当处理器对这个数据进行修改操作的时候，会**重新从系统内存中把数据读到处理器缓存里**。

### 禁止指令重排原理

禁止指令重排的情况：

- 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
- 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
- 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

实现原理：

volatile通过添加读写屏障来禁止指令重排。

- 在每个volatile写操作的前后插入一个StoreStore屏障
- 在每个volatile读操作的后面插入一个LoadLoad屏障

![volatile 禁止指令重排的读写屏障原理](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202110131743529.png)







# Lock锁

## Lock锁的使用

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
} finally {
    lock.unlock();
}
```

在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。

不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。

## Lock接口提供的synchronized关键字所不具备的主要特性

![Lock接口提供的synchronized关键字所不具备的主要特性](https://cos.duktig.cn/typora/202110160911861.png)

`Lock`的主要API：

![Lock的主要API](https://cos.duktig.cn/typora/202110160912526.png)



# AQS

## 什么是AQS？

> 队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。
>
> **同步器的主要使用方式**：继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，它**独占式**和**共享式**两种方式获取同步状态，多线程并发情况下通过CAS的方式修改同步状态。
>
> 同步器的设计基于**模板方法模式**：
>
> 1. 继承同步器并重写指定的方法
> 2. 将同步器组合在自定义同步组件的实现中
> 3. 调用同步器提供的模板方法
> 4. 模板方法将会调用使用者重写的方法

## 为什么要使用AQS？

锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；

同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。

锁和同步器很好地隔离了使用者和实现者所需关注的领域。

## AQS的API

### 同步器可重写的方法

![AQS 可重写的方法](https://cos.duktig.cn/typora/202110160950056.png)

### 同步器提供的模板方法

同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。

![AQS提供的模板方法](https://cos.duktig.cn/typora/202110160951509.png)

## AQS实战——自定义同步组件

独占锁（互斥锁）Mutex是一个自定义同步组件，它**在同一时刻只允许一个线程占有锁**。

### 实现思路

继承同步器的思路：

- Mutex中定义了一个静态内部类，该内部类继承了同步器并实现了独占式获取和释放同步状态。
- `tryAcquire(int acquires)`：如果经过CAS设置成功（同步状态设置为1），则代表获取了同步状态。存在并发抢占，所以需要使用CAS来获取锁（`compareAndSetState`）。
- `tryRelease(int releases)`：只是将同步状态重置为0。因为同一时刻只有一个线程可以获取到锁，不能存在并发问题，所以直接使用`setState`即可，不用使用CAS。

锁Mutex的思路：

- 用户使用Mutex时并不会直接和内部同步器的实现打交道，而是调用Mutex提供的方法。
- 在Mutex的实现中，调用同步器的模板方法即可，大大降低了实现一个**可靠自定义同步组件**的门槛。

### 代码实现

```java
/**
 * description:自定义同步组件（AQS原理）——互斥锁：同一个时刻只允许有一个锁占有线程
 *
 * @author RenShiWei
 * Date: 2021/7/5 21:25
 **/
public class Mutex implements Lock {

    /**
     * 静态内部类自定义AQS同步器
     */
    private static class Sync extends AbstractQueuedSynchronizer {

        /**
         * 当前同步器是否处于占用状态（因为只有一个线程可以占用，所以state为1时代表占用）
         */
        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        /**
         * 独占式获取锁
         * 当状态为0时，说明没有线程占用；因为存在多线程并发抢占锁，所以使用CAS操作进行获取锁
         */
        @Override
        public boolean tryAcquire(int acquires) {
            if (compareAndSetState(0, 1)) {
                // 设置那个线程获取到这个锁
                super.setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        /**
         * 释放锁，将同步状态设置为0
         * 只有一个线程可以获取到锁，释放锁时不存在并发抢占，因此不需要CAS操作
         */
        @Override
        protected boolean tryRelease(int releases) {
            if (getState() == 0) {
                throw new IllegalMonitorStateException();
            }
            // 将锁的持有者置空
            setExclusiveOwnerThread(null);
            // 设置同步状态
            setState(0);
            return true;
        }

        /**
         * @return 一个Condition，每个condition都包含了一个condition队列
         */
        Condition newCondition() { return new ConditionObject(); }

    }

    /**
     * 仅需要将操作代理到Sync上即可
     */
    private final Sync sync = new Sync();

    /**
     * 获取锁
     */
    @Override
    public void lock() {
        sync.acquire(1);
    }

    /**
     * 可中断的获取锁
     *
     * @throws InterruptedException 当前线程被中断，抛出中断异常
     */
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    /**
     * 非阻塞获取锁
     *
     * @return 获取失败，立即返回false
     */
    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    /**
     * 中断、非阻塞、超时 获取锁
     */
    @Override
    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }

    /**
     * 释放锁
     */
    @Override
    public void unlock() {
        sync.release(1);
    }

    /**
     * @return lock的 Condition对象
     */
    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }

    /**
     * 独占模式下 同步器是否被占用（一般表示，是否被当前线程所占用）
     */
    public boolean isLocked() { return sync.isHeldExclusively(); }

    /**
     * @return 等待队列上是否有线程
     */
    public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }

}
```

## AQS的原理分析

从实现角度分析同步器是如何完成线程同步的，主要包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。

### 同步队列

同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点，节点的属性类型与名称以及描述如下表所示：

![同步队列的一个几点](https://cos.duktig.cn/typora/202110161407505.png)

同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部，同步队列的基本结构如图：

![同步队列的基本结构](https://cos.duktig.cn/typora/202110161414525.png)



**插入尾节点时**，可能存在并发问题，所以需要使用CAS设置尾节点的方法：`compareAndSetTail(Node expect,Node update)`，`expect`代表尾节点，`update`代表当前节点。

**获取同步状态**：

同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点，该过程如下图：

![获取同步状态成功的节点示意图](https://cos.duktig.cn/typora/202110161414652.png)

设置首节点是通过获取同步状态成功的线程来完成的，**由于只有一个线程能够成功获取到同步状态**，因此设置头节点的方法并不需要使用CAS来保证，它只需要**将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可**。

### 独占式同步状态获取与释放

独占式同步状态获取流程，也就是acquire(int arg)方法调用流程，如图：

![独占式获取同步状态](https://cos.duktig.cn/typora/202110161433684.png)

获取独占式同步状态：

1. 同步器维护一个同步队列，获取同步状态成功直接返回。
2. **获取同步状态失败的线程会被构造成节点，循环CAS（死循环式自旋保证节点正确添加）加入到队列尾部**。
3. 节点自旋加入尾部成功后，**如果是头结点尝试获取同步状态**，随后退出自旋，其他线程唤醒依靠前驱节点出队或阻塞的线程被中断。
4. 移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。

释放独占式同步状态：

1. 同步器调用`tryRelease(int arg)`方法释放同步状态。
2. 唤醒头节点的后继节点。



### 共享式同步状态获取与释放

共享式获取与独占式获取最主要的区别：**同一时刻能否有多个线程同时获取到同步状态**。

以文件读写为例，共享式同步状态支持 **并发读和独占写**，具体不同如下图：

 ![共享式与独占式访问资源的对比](https://cos.duktig.cn/typora/202110161547964.png)

在共享式获取的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。

与独占式一样，共享式获取在释放同步状态后，将会唤醒后续处于等待状态的节点。与独占式不同的是，释放同步状态要保证线程安全（释放同步状态的操作会同时来自多个线程），需要使用CAS操作。

### 独占式超时获取同步状态

#### 响应中断的同步状态获取

在Java 5之前，当一个线程获取不到锁而被阻塞在`synchronized`之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在`synchronized`上，等待着获取锁。

在Java 5中，同步器提供了`acquireInterruptibly(int arg)`方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出`InterruptedException`。

#### 超时的同步状态获取

超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”。

`doAcquireNanos(int arg,long nanosTimeout)`方法在支持响应中断的基础上，增加了超时获取的特性。

> 针对超时获取，主要需要计算出需要睡眠的时间间隔nanosTimeout，为了防止过早通知，nanosTimeout计算公式为：nanosTimeout-=now-lastTime，其中now为当前唤醒时间，lastTime为上次唤醒时间，如果nanosTimeout大于0则表示超时时间未到，需要继续睡眠nanosTimeout纳秒，反之，表示已经超时。
>
> 如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行超时等待，而是进入快速的自旋过程。原因于，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确。因此，在超时非常短的场景下，同步器会进入无条件的快速自旋。

具体过程如下：

![超时的同步状态获取流程](https://cos.duktig.cn/typora/202110161619650.png)

# ReetrantLock

## 什么是ReetrantLock？

> 重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。

### 锁为什么要支持可重入？

**如果锁不支持可重入，再次调用`lock()`方法，则该线程将会被自己所阻塞**。即调用`tryAcquire(int acquires)`方法时获取同步状态返回了false，标识当前锁已被持有，导致该线程被阻塞。

### 锁的公平性问题

如果在绝对时间上，**先对锁进行获取的请求一定先被满足，那么这个锁是公平的**，反之，是不公平的。

公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。

公平的锁机制往往没有非公平的效率高，但是**公平锁能够减少“饥饿”发生的概率**，等待越久的请求越是能够得到优先满足。

## 重入锁实现原理

重进入是指**任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞**。

该特性的实现需要解决以下两个问题：

1. **线程再次获取锁**。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。
2. **锁的最终释放**。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。

### 重入锁加锁

以非公平性（默认的）实现为例分析重入锁的实现，重入锁的加锁逻辑：

- 通过判断当前线程是否为获取锁的线程来决定获取操作是否成功
- 如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。
- 成功获取锁的线程再次获取锁，只是增加了同步状态值（这也就要求ReentrantLock在释放同步状态时减少同步状态值）

代码分析：

> `ReentrantLock`的`nonfairTryAcquire`方法
>
> ```java
> final boolean nonfairTryAcquire(int acquires) {
>     final Thread current = Thread.currentThread();
>     int c = getState();
>     // c为0，表示第一次获取锁
>     if (c == 0) {
>         if (compareAndSetState(0, acquires)) {
>             setExclusiveOwnerThread(current);
>             return true;
>         }
>         // 不是第一次获取先判断当前线程是否为持有锁的线程
>     } else if (current == getExclusiveOwnerThread()) {
>         int nextc = c + acquires;
>         if (nextc < 0)
>             throw new Error("Maximum lock count exceeded");
>         // 设置增加的同步状态
>         setState(nextc);
>         // 返回true表示加锁成功
>         return true;
>     }
>     return false;
> }
> ```



### 重入锁释放

重入锁的释放逻辑：

- 如果该锁被获取了n次，那么前(n-1)次`tryRelease(int releases)`方法必须返回`false`，而只有同步状态完全释放了，才能返回`true`。

- 该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为`null`，并返回`true`，表示释放成功。

代码分析：

> `ReentrantLock`的`tryRelease`方法
>
> ```java
> protected final boolean tryRelease(int releases) {
>  int c = getState() - releases;
>  if (Thread.currentThread() != getExclusiveOwnerThread())
>          throw new IllegalMonitorStateException();
>  boolean free = false;
>  if (c == 0) {
>          free = true;
>          setExclusiveOwnerThread(null);
>  }
>  setState(c);
>  return free;
> }
> ```

## 公平与非公平获取锁的区别

> **公平锁**：采用**先到先得**的策略，每次获取锁时都会检查队列里有没有排队等待的线程，没有才尝试获取锁，如果有就将当前线程追加到队列中。
>
> **非公平锁**：采用有机会插队的策略，一个线程获取锁之前要先尝试获取锁而不是在队列中等待，如果获取锁成功，则说明线程虽然是后启动的，但先获得了锁，这就是“作弊插队”的效果。如果没有获取锁成功，那么将自身追加到队列中进行等待。

#### 公平锁的实现分析

公平性与否是针对获取锁而言的，**如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO**。

> 介绍的`nonfairTryAcquire(int acquires)`方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同，如代码：
>
> ```java
> protected final boolean tryAcquire(int acquires) {
>     final Thread current = Thread.currentThread();
>     int c = getState();
>     if (c == 0) {
>         if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
>             setExclusiveOwnerThread(current);
>             return true;
>         }
>     } else if (current == getExclusiveOwnerThread()) {
>         int nextc = c + acquires;
>         if (nextc < 0)
>             throw new Error("Maximum lock count exceeded");
>         setState(nextc);
>         return true;
>     }
>     return false;
> }
> ```

该方法与`nonfairTryAcquire(int acquires)`比较，唯一不同的位置为判断条件多了`hasQueuedPredecessors()`方法，即**加入了同步队列中当前节点是否有前驱节点的判断**，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。

#### 为什么非公平锁会出现线程连续获取锁的情况呢？

`nonfairTryAcquire(int acquires)`方法，当一个线程请求锁时，只要获取了同步状态即成功获取锁。在这个前提下，**刚释放锁的线程再次获取同步状态的几率会非常大**，使得其他线程只能在同步队列中等待。



#### 非公平性锁可能使线程“饥饿”，为什么它又被设定成默认的实现呢？

如果把每次不同线程获取到锁定义为1次切换，公平性锁在测试中进行了10次切换，而非公平性锁只有5次切换，这说明**非公平性锁的开销更小**。

下面运行测试用例（测试环境：ubuntuserver 14.04 i5-34708GB，测试场景：10个线程，每个线程获取100000次锁），通过vmstat统计测试运行时系统线程上下文切换的次数，运行结果如表：

![公平锁和非公平锁 上下文切换次数比较](https://cos.duktig.cn/typora/202110161709694.png)

在测试中公平性锁与非公平性锁相比，总耗时是其94.3倍，总切换次数是其133倍。

可以看出，**公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换**。**非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量**。

# ReentrantReadWriteLock

## 什么是读写锁？

ReentrantLock是排它锁，在同一时刻只允许一个线程进行访问。而**读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读**
**线程和其他写线程均被阻塞**。

读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。

## 为什么要使用读写锁？

除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。

> 以一个场景为例：假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。

**在没有读写锁支持的**（Java 5之前）时候实现方式：

使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步）。

这样做的目的是使读操作能读取到正确的数据，不会出现脏读。

**使用读写锁实现**：

只需要在读操作时获取读锁，写操作时获取写锁即可。

当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。

**使用场景**：

一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的**并发性**和**吞吐量**。

## ReentrantReadWriteLock的使用

### 读写锁的特性

![ReentrantReadWriteLock的特性](C:\Users\rsw\AppData\Roaming\Typora\typora-user-images\image-20211016172530817.png)

### 读写锁的接口

ReadWriteLock仅定义了获取读锁和写锁的两个方法，即`readLock()`方法和`writeLock()`方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法，这些方法以及描述如表：

![ReentrantReadWriteLock 部分API](https://cos.duktig.cn/typora/202110161729546.png)



### 读写锁示例

利用读写锁实现HashMap线程安全的缓存。

代码如下：

```java
/**
 * description: 读写锁缓存的实现（ReentrantReadWriteLock示例）
 *
 * @author RenShiWei
 * Date: 2021/10/16 17:30
 * blog: https://duktig.cn/
 * github知识库: https://github.com/duktig666/knowledge
 **/
public class ReadWriteLockCache {

    static Map<String, Object> map = new HashMap<String, Object>();
    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    static Lock r = rwl.readLock();
    static Lock w = rwl.writeLock();

    /**
     * 获取一个key对应的value
     */
    public static Object get(String key) {
        r.lock();
        try {
            return map.get(key);
        } finally {
            r.unlock();
        }
    }

    /**
     * 设置key对应的value，并返回旧的value
     *
     * @param key   /
     * @param value /
     * @return 旧的value
     */
    public static Object put(String key, Object value) {
        w.lock();
        try {
            return map.put(key, value);
        } finally {
            w.unlock();
        }
    }

    /**
     * 清空所有的内容
     */
    public static void clear() {
        w.lock();
        try {
            map.clear();
        } finally {
            w.unlock();
        }
    }

}
```

## ReentrantReadWriteLock原理分析

分析 `ReentrantReadWriteLock` 的实现，主要包括：读写状态的设计、写锁的获取与释放、读锁的获取与释放以及锁降级。

### 读写状态的设计

#### 读写锁同步状态的设计

读写锁同样依赖自定义同步器来实现同步功能，而**读写状态就是其同步器的同步状态**。

在`ReentrantLock`中自定义同步器的实现，同步状态表示**锁被一个线程重复获取的次数**；而读写锁的自定义同步器需要**在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态**。

如果在一个整型变量上维护多种状态，就一定需要“**按位切割使用**”这个变量，读写锁将变量切分成了两个部分，**高16位表示读，低16位表示写**，划分方式如图：

![读写锁状态的划分方式](https://cos.duktig.cn/typora/202110161737766.png)

当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。

#### 读写锁是如何迅速确定读和写各自的状态？

通过位运算。

假设当前同步状态值为S，写状态等于S&0x0000FFFF（将高16位全部抹去），读状态等于S>>>16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1<<16)，也就是S+0x00010000。

根据状态的划分能得出一个推论：S不等于0时，当写状态（S&0x0000FFFF）等于0时，则读状态（S>>>16）大于0，即读锁已被获取。



### 写锁的获取与释放

写锁是一个**支持重进入的排它锁**。

如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。

> ReentrantReadWriteLock的tryAcquire方法：
>
> ```java
> protected final boolean tryAcquire(int acquires) {
>     Thread current = Thread.currentThread();
>     int c = getState();
>     int w = exclusiveCount(c);
>     if (c != 0) {
>         // 存在读锁或者当前获取线程不是已经获取写锁的线程
>         if (w == 0 || current != getExclusiveOwnerThread())
>             return false;
>         if (w + exclusiveCount(acquires) > MAX_COUNT)
>             throw new Error("Maximum lock count exceeded");
>         setState(c + acquires);
>         return true;
>     }
>     if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) {
>         return false;
>     }
>     setExclusiveOwnerThread(current);
>     return true;
> }
> ```

该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。

如果存在读锁，则写锁不能被获取，原因在于：读写锁要**确保写锁的操作对读锁可见**，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。

写锁的释放与ReentrantLock的释放过程基本类似。

### 读锁的获取与释放

读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，**在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取**，而所做的也只是（线程安全的）增加读状态。

**读状态是所有线程获取读锁次数的总和**，而**每个线程各自获取读锁的次数只能选择保存在ThreadLocal中**，由线程自身维护。

> 获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如`getReadHoldCount()`方法，作用是返回当前线程获取读锁的次数。如下代码做了删减，保留必要部分。
>
> ```java
> protected final int tryAcquireShared(int unused) {
>  for (;;) {
>      int c = getState();
>      int nextc = c + (1 << 16);
>      if (nextc < c)
>          throw new Error("Maximum lock count exceeded");
>      if (exclusiveCount(c) != 0 && owner != Thread.currentThread())
>          return -1;
>      if (compareAndSetState(c, nextc)) 
>          return 1;
>  }
> }
> ```

在 `tryAcquireShared(int unused)` 方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。

读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1<<16）。

### 锁降级

锁降级指的是**写锁降级成为读锁**。

如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。**锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程**。

> 锁降级示例：
>
> ```java
> public void processData() {
>  readLock.lock();
>  if (!update) {
>      // 必须先释放读锁
>      readLock.unlock();
>      // 锁降级从写锁获取到开始
>      writeLock.lock();
>      try {
>          if (!update) {
>              // 准备数据的流程（略）
>              update = true;
>          }
>          readLock.lock();
>      } finally {
>          writeLock.unlock();
>      }
>      // 锁降级完成，写锁降级为读锁
>  }
>  try {
> 
> 
>      // 使用数据的流程（略）
>  } finally {
>      readLock.unlock();
>  }
> }
> ```
>
> 当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。

**锁降级中读锁的获取是否必要呢？**

必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。

如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。

**RentrantReadWriteLock是否支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）？**

不支持。目的也是保证数据可见性，如**果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的**。



# Condition接口

## 什么是Condition？

任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现**等待/通知模式**。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等通知模式，但是这两者在使用方式以及功能特性上还是有差别的。具体如下：

![Object的监视器方法与Condition接口的对比](https://cos.duktig.cn/typora/202110162008580.png)

## 如何使用Condition？

Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的`newCondition()`方法）创建出来的，换句话说，Condition是依赖Lock对象的。

```java
Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();

public void conditionWait() throws InterruptedException {
    lock.lock();
    try {
        condition.await();
    } finally {
        lock.unlock();
    }
}

public void conditionSignal() throws InterruptedException {
    lock.lock();
    try {
        condition.signal();
    } finally {
        lock.unlock();
    }
}
```

Condition定义的（部分）方法以及描述如下：

![Condition定义的（部分）方法](https://cos.duktig.cn/typora/202110162013958.png)

获取一个Condition必须通过Lock的`newCondition()`方法。

## Condition实战——实现阻塞队列

```java
/**
 * description:数组来实现简单的阻塞队列
 * <p>
 * 使用 ReentrantLock + Condition
 *
 * @author RenShiWei
 * Date: 2021/8/6 17:06
 **/
public class ArrayBlockQueue<T> {

    /** 存放元素的数组 */
    private T[] data;

    /** 实际的元素个数 */
    private int count;

    /** 队首指针 */
    private int head;

    /** 队尾指针 */
    private int tail;

    private Lock lock = new ReentrantLock();
    private Condition notFullCondition = lock.newCondition();
    private Condition notEmptyCondition = lock.newCondition();

    @SuppressWarnings("unchecked")
    public ArrayBlockQueue(int len) {
        data = (T[]) new Object[len];
    }

    /**
     * 阻塞队列入队
     *
     * @param t 入队元素
     */
    public void put(T t) {
        lock.lock();
        try {
            while (count >= data.length) {
                try {
                    System.out.println(Thread.currentThread().getName() + "队列已满，put操作阻塞线程");
                    notFullCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            this.data[tail] = t;
            this.tail = (tail + 1) % this.data.length;
            count++;
            notEmptyCondition.signal();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 阻塞队列出队
     *
     * @return 出队元素
     */
    public T take() {
        lock.lock();//获取锁不能写在try块中，如果发生异常，锁会被释放
        try {
            while (count == 0) {
                try {
                    System.out.println(Thread.currentThread().getName() + "队列已空，take操作阻塞线程");
                    notEmptyCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = data[head];
            this.head = (head + 1) % data.length;
            count--;
            notFullCondition.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    /**
     * 测试
     */
    @SuppressWarnings("all")
    public static void main(String[] args) {
        ArrayBlockQueue<Integer> blockingQueue = new ArrayBlockQueue<>(10);
        Thread thread = new Thread(() -> {
            for (int i = 0; i < 9; i++) {
                blockingQueue.put(i);
                System.out.println("put-num:" + i);
            }
        });
        try {
            thread.start();
            //等待thread执行完毕后再进行操作
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                Integer num = blockingQueue.take();
                System.out.println(Thread.currentThread().getName() + "-take-num:" + num);
            }
        }).start();

        new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                Integer num = blockingQueue.take();
                System.out.println(Thread.currentThread().getName() + "-take-num:" + num);
            }
        }).start();

    }

}
```

## Condition的原理分析

ConditionObject是同步器`AbstractQueuedSynchronizer`的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。

**每个Condition对象都包含着一个队列（以下称为等待队列）**，该队列是Condition对象实现等待/通知功能的关键。

Condition的实现，主要包括：等待队列、等待和通知。

### 等待队列

等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程。**如果一个线程调用了  `Condition.await()` 方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态**。

> 事实上，节点的定义复用了同步器中节点的定义，也就是说，**同步队列和等待队列中节点类型都是同步器的静态内部类** `AbstractQueuedSynchronizer.Node`。

一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用`Condition.await()`方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如图:

![等待队列的基本结构](https://cos.duktig.cn/typora/202110162018219.png)

上述**节点引用更新的过程并没有使用CAS保证**，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说**该过程是由锁来保证线程安全的**。

在Object的监视器模型上（synchronized），一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有**一个同步队列和多个等待队列**，其对应关系如图：

![同步队列与等待队列](https://cos.duktig.cn/typora/202110162020261.png)

### 等待机制

调用Condition的`await()`方法（或者以await开头的方法），会**使当前线程进入等待队列并释放锁，同时线程状态变为等待状态**。

当从`await()`方法返回时，当前线程一定获取了Condition相关联的锁。

如果从队列（同步队列和等待队列）的角度看`await()`方法，**当调用`await()`方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中**。

> ConditionObject的await方法
>
> ```java
> public final void await() throws InterruptedException {
>  if (Thread.interrupted())
>      throw new InterruptedException();
>  // 当前线程加入等待队列
>  Node node = addConditionWaiter();
>  // 释放同步状态，也就是释放锁
>  int savedState = fullyRelease(node);
>  int interruptMode = 0;
>  while (!isOnSyncQueue(node)) {
>      LockSupport.park(this);
>      if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
>          break;
>  }
>  if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
>      interruptMode = REINTERRUPT;
>  if (node.nextWaiter != null)
>      unlinkCancelledWaiters();
>  if (interruptMode != 0)
>      reportInterruptAfterWait(interruptMode);
> }
> ```

调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。

如果从队列的角度去看，当前线程加入Condition的等待队列，该过程如图：

![当前线程加入等待队列](https://cos.duktig.cn/typora/202110162023047.png)



如图所示，同步队列的首节点并不会直接加入等待队列，而是通过`addConditionWaiter()`方法把当前线程构造成一个新的节点并将其加入等待队列中。

### 通知机制

调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。

> ConditionObject的signal方法
>
> ```java
> public final void signal() {
>  if (!isHeldExclusively())
>      throw new IllegalMonitorStateException();
>  Node first = firstWaiter;
>  if (first != null)
>      doSignal(first);
> }
> ```

调用该方法的前置条件是当前线程必须获取了锁，可以看到`signal()`方法进行了`isHeldExclusively()`检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。

节点从等待队列移动到同步队列的过程如图:

![节点从等待队列移动到同步队列](https://cos.duktig.cn/typora/202110162025326.png)

通过调用同步器的`enq(Node node)`方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。

被唤醒后的线程，将从`await()`方法中的while循环中退出(`isOnSyncQueue(Node node)`方法返回`true`，节点已经在同步队列中），进而调用同步器的`acquireQueued()`方法加入到获取同步状态的竞争中。

成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的`await()`方法返回，此时该线程已经成功地获取了锁。

Condition的`signalAll()`方法，相当于对等待队列中的每个节点均执行一次`signal()`方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。

总结：

1. 等待队列中的头节点线程安全地移动到同步队列，然后被唤醒。
2. 被唤醒后的线程，从`await()`方法中的while循环中退出，并进行同步状态的竞争
3. 成功获取到同步状态后，被唤醒的线程将从先前调用的`await()`方法返回。











# 线程池

## 1. 为什么使用线程池？

> **池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。**

**线程池**提供了一种限制和管理资源(包括执行一个任务)。 每个**线程池**还维护一些基本统计信息，例如已完成任务的数量。

《Java 并发编程的艺术》提到的**使用线程池的好处**：

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## 2. 如何创建线程池？

《阿里巴巴 Java 开发手册》中强制线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor `的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

### 2.1 Executors 和ExecutorService返回线程池对象的弊端

#### 2.1.1 简介

> JDK 5.0起提供了线程池相关API：` ExecutorService` 和 `Executors`。

`ExecutorService`：真正的线程池接口。常见子类`ThreadPoolExecutor`

- `void execute(Runnable command)` ：执行任务/命令，没有返回值，一般用来执行`Runnable`
- `<T> Future<T> submit(Callable<T> task)`：执行任务，有返回值，一般又来执行`Callable`
- `void shutdown() `：关闭连接池

`Executors`：工具类、线程池的工厂类，用于创建并返回不同类型的线程池：

- `Executors.newCachedThreadPool()`：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 (可根据需要创建新线程的线程池)
  - 创建方式： `Executors.newCachedThreadPool()`；
- `Executors.newFixedThreadPool(n)`: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置，如`Runtime.getRuntime().availableProcessors()`。 
  - 创建方式： `Executors.newFixedThreadPool()`；
- `Executors.newSingleThreadExecutor()` ：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 
  - 创建方式： `Executors.newSingleThreadExecutor ()`；
- `Executors.newScheduledThreadPool(n)`：创建一个定长线程池，支持定时及周期性任务执行。 
  - 创建方式： `Executors.newScheduledThreadPool ()`；

#### 2.1.2 Executors 返回线程池对象的弊端

**FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。

**CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

> **Out Of Memory(OOM)**，一般是由于程序编写者对内存使用不当，如对该释放的内存资源没有释放，导致其一直不能被再次使用而使计算机内存被耗尽的现象。



### 2.2 ThreadPoolExecutor创建线程池

#### 2.2.1 构造方法

```java
public class ThreadPoolExecutor extends AbstractExecutorService {

    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);

}
```

`ThreadPoolExecutor`继承了`AbstractExecutorService`类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。

#### 2.2.2 通过ThreadPoolExecutor可以实现 Executors的三种不同类型的线程池

![image-20210614211916188](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/ThreadPoolExecutor%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%20Executors%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0.png)

## 3. ThreadPoolExecutor 类分析

```java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

### 3.1 构造器参数详解：

- **`corePoolSize`**： ==**核心线程数线程数定义了最小可以同时运行的线程数量**==。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
- **`maximumPoolSize`**：**线程池最大线程数**。它表示在线程池中最多能创建多少个线程；
- **`keepAliveTime`**：**表示线程没有任务执行时最多保持多久时间会终止**。默认情况下，**只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用**，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
- **`unit`**：**参数keepAliveTime的时间单位**，有7种取值。TimeUnit.DAYS、TimeUnit.HOURS、TimeUnit.MINUTES、TimeUnit.SECONDS、TimeUnit.MILLISECONDS、TimeUnit.MICROSECONDS、TimeUnit.NANOSECONDS
- **`workQueue`**：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue。 
  ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和SynchronousQueue。线程池的排队策略与BlockingQueue有关。
- **`threadFactory`**：`executor`创建新线程的时候会用到；
- **`handler`**：**表示当拒绝处理任务时的策略(饱和策略)**，四种取值，参看下文。

### 3.2 饱和策略

> 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，`ThreadPoolTaskExecutor` 定义的一些策略。

- `ThreadPoolExecutor.AbortPolicy`:丢弃任务并抛出`RejectedExecutionException`异常。 
- `ThreadPoolExecutor.DiscardPolicy`：也是丢弃任务(不处理)，但是不抛出异常。 
- `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃最早的未处理的任务请求，然后重新尝试执行任务(重复此过程) 
- `ThreadPoolExecutor.CallerRunsPolicy`：**调用执行自己的线程运行任务**。也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。

## 4. 线程池原理

![线程池原理](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202109261001194-167687342985622.png)

参看：[线程池原理分析](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_47-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90)

### 4.1 execute()方法和 submit()方法的区别

1. **`execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；**
2. **`submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功**，并且可以通过 `Future` 的 `get()`方法来获取返回值，`get()`方法会阻塞当前线程直到任务完成，而使用 `get(long timeout，TimeUnit unit)`方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

我们以**`AbstractExecutorService`**接口中的一个 `submit` 方法为例子来看看源代码：

```java
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
```

上面方法调用的 `newTaskFor` 方法返回了一个 `FutureTask` 对象。

```java
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
```

我们再来看看`execute()`方法：

```java
    public void execute(Runnable command) {
      ...
    }
```

### 4.2 线程池的执行过程

1. 当工作线程数 < corePoolSize 时，新创建一个新线程执行新提交任务，即使此时线程池中存在空闲线程；
2. 当工作线程数 == corePoolSize 时，新提交任务将被放入 workQueue 中；
3. 当 workQueue 已满，且工作线程数 < maximumPoolSize 时，新提交任务会创建新的非核心线程执行任务；
4. 当 workQueue 已满，且 工作线程数==maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理；

![img](images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/202201151513688.png)

## 线程池问题的排查

参看：[一次线上线程池任务问题处理历程(小米信息技术部)](https://xiaomi-info.github.io/2019/12/19/theadpool-rejected-task/)





# 操作

## 基本概念

> 原子(atomic)：不能被进一步分割的最小粒子。
>
> 原子操作(atomic operation)：不可被中断的一个或一系列操作。
>
> **CAS**(比较并交换，Compare and Swap)：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，**在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换**。



## 处理器如何实现原子操作？

如果多个处理器同时对共享变量进行读改写操作(**i++就是经典的读改写操作**)，因为操作不是原子性的，所以可能出现共享变量的值会和期望的不一致的问题。

> `i++` 不是一个操作，而是三个操作：
>
> 1. get取到 `i `的值
> 2. 进行 `+1` 操作
> 3. put写 `i` 的值

原因可能是：**多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中**。

### 使用总线锁保证原子性

处理器可以使用 **总线锁** 保证原子性。基本思想如下：

处理器提供的一个**LOCK＃**信号，**当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存**。

### 使用缓存锁保证原子性

#### **总线锁的缺陷**：

在同一时刻，我们**只需保证对某个内存地址的操作是原子性**即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以**总线锁定的开销比较大**。

#### **缓存锁基本思想**：

处理器不在总线上声言LOCK＃信号，而是**修改内部的内存地址**，并允许它的**缓存一致性机制**来保证操作的原子性，因为**缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效**。

#### **处理器不会使用缓存锁定的两种情况**：

1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行(cache line)时，则处理器会调用总线锁定。
2. 有些处理器不支持缓存锁定。

## Java如何实现原子操作？

在Java中可以通过 **锁** 和 **循环CAS** 的方式来实现原子操作。

### 循环CAS 实现原子操作

#### 什么是CAS?

JVM中的CAS操作正是利用了处理器提供的 **CMPXCHG指令** 实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。

从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如`AtomicBoolean`(用原子方式更新的boolean值)、`AtomicInteger`(用原子方式更新的int值)和`AtomicLong`(用原子方式更新的long值)。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。

#### CAS实现原子操作的三大问题

##### 1. ABA问题

CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现 **它的值没有发生变化，但是实际上却变化了** 。

ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么 **A->B->A就会变成1A->2B->3A**。

Java 1.5开始，JDK的Atomic包里提供了一个类 `AtomicStampedReference` 来解决ABA问题。这个类的 `compareAndSet` 方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

```java
public boolean compareAndSet(
    V          expectedReference,         // 预期引用
    V          newReference,              // 更新后的引用
    int         expectedStamp,            // 预期标志
    int         newStamp                  // 更新后的标志
)
```

##### 2. 循环时间长开销大

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：**第一，它可以延迟流水线执行指令(depipeline)，使CPU不会消耗过多的执行资源**，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；**第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率**。

CAS自旋长时间，可以考虑使用失败策略。自旋达到一定的次数/时间，可以执行相应的处理——抛出异常/回滚。

##### 3. 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。

两个办法：

1. 使用锁
2. 把多个共享变量合并成一个共享变量来操作。从Java 1.5开始，提供了 `AtomicReference` 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

### 锁 实现原子操作

锁机制保证了 **只有获得锁的线程才能够操作锁定的内存区域** ，可以保证原子性。

## concurrent包的实现原理

volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：

1. 声明共享变量为 `volatile`。
2. 使用CAS的原子条件更新来实现线程之间的同步。
3. 配合以`volatile`的读/写和CAS所具有的`volatile`读和写的内存语义来实现线程之间的通信。

AQS，非阻塞数据结构和原子变量类(`java.util.concurrent.atomic`包中的类)，这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：

![concurrent包的实现示意图](https://cos.duktig.cn/typora/202110131748342.png)









参看：[Atomic 原子类](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_5-atomic-%e5%8e%9f%e5%ad%90%e7%b1%bb)



# Java处理线程安全问题

## 1. 线程安全问题

### 1.1 什么是线程安全？

> 线程安全：多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。

> 非线程安全问题：指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。

"线程安全"不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。

目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。但是**进程中的多个线程共享进程的堆内存**，这就是造成问题的潜在原因。

假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。

*比如把你住的小区看作一个进程，小区里的道路/绿化等就属于公共区域。你拿1万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。*

> 所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。

即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程"破坏"。

### 1.2 产生的原因

1. 多个线程执行的不确定性引起执行结果的不稳定。
2. 多个线程对数据的共享，会造成操作的不完整性，会破坏数据。

当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行，导致共享数据的错误。

### 1.3 实例（买票超卖问题）

```java
/**
 * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式
 *
 * 存在线程的安全问题，待解决。
 */
class Window extends Thread{

    private static int ticket = 100;
    @Override
    public void run() {

        while(true){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if(ticket > 0){
                System.out.println(getName() + "：卖票，票号为：" + ticket);
                ticket--;
            }else{
                break;
            }
        }

    }
}

public class WindowTest {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}
```

**结果**

出现了共享数据错误

```java
窗口2：卖票，票号为：100
窗口1：卖票，票号为：100
窗口3：卖票，票号为：98
窗口3：卖票，票号为：97
窗口2：卖票，票号为：97
窗口1：卖票，票号为：95
窗口1：卖票，票号为：94
窗口2：卖票，票号为：93
窗口3：卖票，票号为：92
窗口3：卖票，票号为：91
......
窗口1：卖票，票号为：10
窗口3：卖票，票号为：10
窗口2：卖票，票号为：10
窗口2：卖票，票号为：7
窗口3：卖票，票号为：7
窗口1：卖票，票号为：5
窗口3：卖票，票号为：4
窗口2：卖票，票号为：4
窗口1：卖票，票号为：2
窗口2：卖票，票号为：1
窗口3：卖票，票号为：1
```

**分析**

1. 问题：三条线程同时共享ticket的票，卖票过程中，出现了重票、错票 -->出现了线程的安全问题，导致数据错误。
2. 原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。
3. 解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。

### 1.4 如何确定是否存在线程安全问题？

- 明确哪些代码是多线程运行的代码
- 明确多个线程是否有共享数据
- 明确多线程运行代码中是否有多条语句操作共享数据

## 2. 如何解决线程安全问题？



如何解决线程安全问题？解决的过程其实就是一个取舍的过程，不同的方案有不同的侧重点。

### 2.1 不可变（Immutable）

不可变的对象一定是线程安全的，不需要采取任何的线程安全措施。只要一个不可变的对象被正确的构建出来，在多线程的状态下也不允许修改，那么一定不会发生不一致的状态。

形象比喻：**只能看，不能摸**。自然不会存在线程安全问题。



在多线程的环境下，应尽量是对象成为不可变的状态，来满足线程安全，这基本也是最小的开销方式来保证线程安全。

> 不可变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。

不可变的类型：

- `String`
- 枚举类型
- 基本数据类型的包装类以及`BigInteger` 和 `BigDecimal` 等大数据类型
- final关键字修饰的基本数据类型

注：**final修饰的引用数据类型不可变，但其成员变量的类可能会发生改变**。



### 2.2 变量私有化

要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。

#### 2.2.1 栈封闭（主要为局部变量）

**多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的**。

形象比喻：**私有的东西就不该让别人知道**。



**如果一些数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中**。较为常见的就是局部变量。

```java
double avgScore(double[] scores) {
    double sum = 0;
    for (double score : scores) {
        sum += score;
    }
    int count = scores.length;
    double avg = sum / count;
    return avg;
}
```

这里的变量`sum`，`count`，`avg`都是局部变量，它们都会被分配在线程栈内存中。

假如现在A线程来执行这个方法，这些变量会在A的栈内存分配。与此同时，B线程也来执行这个方法，这些变量也会在B的栈内存中分配。

也就是说这些局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道，也就不存在线程安全问题。

**问题**：

不可能所有的变量都只声明成局部变量，而只供某个线程使用，去解决线程安全问题。如果想要声明成员变量，还想要保证线程安全怎么办？

可以使用`ThreadLocal`，使每个线程都私有化一份这个变量的本地副本，互相不受影响。

#### 2.2.2 线程本地存储（Thread Local Storage）

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

可以使用`java.lang.ThreadLocal`类来实现线程本地存储功能。

通俗来说：要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。

形象比喻：**大家不要抢，人人有份**。

 

符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如"生产者-消费者"模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的"一个请求对应一个服务器线程"（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。



为了理解 `ThreadLocal`，先看以下代码：

```java
public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -> {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}
```

它所对应的底层结构图为:

[![ThreadLocal实例内存结构](https://cos.duktig.cn/2021/07/05/1625453067.png)](https://cos.duktig.cn/2021/07/05/1625453067.png)

[ThreadLocal实例内存结构](https://cos.duktig.cn/2021/07/05/1625453067.png)



每个 Thread 都有一个 `ThreadLocal.ThreadLocalMap` 对象。

```java
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
```

当调用一个 `ThreadLocal` 的 `set(T value)` 方法时，先得到当前线程的 `ThreadLocalMap` 对象，然后将 `ThreadLocal->value` 键值对插入到该 Map 中。

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

get() 方法类似。

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

`ThreadLocal` 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。`ThreadLocal`就是，把一个数据复制N份，每个线程认领一份，各玩各的，互不影响。

在一些场景 (尤其是使用线程池) 下，由于 `ThreadLocal.ThreadLocalMap` 的底层数据结构导致 `ThreadLocal` 有内存泄漏的情况，应该**尽可能在每次使用 `ThreadLocal` 后手动调用 `remove()`，以避免出现 `ThreadLocal` 经典的内存泄漏甚至是造成自身业务混乱的风险**。

### 2.3 互斥同步

前面给出的一些方案，有点"理想化"了，现实中的情况其实是非常混乱嘈杂的，没有规则的。

形象比喻：**没有规则，那就先入为主**。

例子：

比如在中午高峰期你去饭店吃饭，进门后发现只剩一个空桌子了，你心想先去点餐吧，回来就坐这里吧。当你点完餐回来后，发现已经被别人捷足先登了。

因为桌子是属于公共区域的物品，任何人都可以坐，那就只能谁先抢到谁坐。虽然你在人群中曾多看了它一眼，但它并不会记住你容颜。

解决方法就不用我说了吧，让一个人在那儿看着座位，其它人去点餐。这样当别人再来的时候，你就可以理直气壮的说，"不好意思，这个座位，我，已经占了"。

相信聪明的你已经猜到了我要说的东西了，没错，就是**互斥锁** 。

 

如果公共区域（堆内存）的数据，要被多个线程操作时，为了确保数据的安全（或一致）性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说吧。

假设一个线程来到数据跟前一看，发现锁是空闲的，没有人持有。于是它就拿到了这把锁，然后开始操作数据。

这时，又来了一个线程，发现锁被别人持有着，按照规定，它不能操作数据，因为它无法得到这把锁。当然，它可以选择等待，或放弃，转而去干别的。

因为第一个线程持有锁，可以大胆干事而不用担心其他线程的影响。



**对于互斥同步锁，可以使用`synchronized` 和 `ReentrantLock`**。

```java
class ClassAssistant {

    double totalScore = 60;
    final Lock lock = new Lock();

    void addScore(double score) {
        lock.obtain();
        totalScore += score;
        lock.release();
    }

    void subScore(double score) {
        lock.obtain();
        totalScore -= score;
        lock.release();
    }
}
```

假定一个班级的初始分数是60分，这个班级抽出10名学生来同时参加10个不同的答题节目，每个学生答对一次为班级加上5分，答错一次减去5分。因为10个学生一起进行，所以这一定是一个并发情形。

因此加分和减分这两个方法被并发的调用，它们共同操作总分数。为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。

**问题**：

互斥阻塞会有**线程阻塞和唤醒**所带来的性能问题。

### 2.4 非阻塞同步

互斥同步属于一种**悲观的并发策略**，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

随着硬件指令集的发展，我们可以使用基于**冲突检测的乐观并发策略**：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。

形象比喻：**相信世界充满爱，即使被伤害**。



由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说**乐观锁天生免疫死锁** 。

乐观锁多用于"读多写少"的环境，避免频繁加锁影响性能；而悲观锁多用于"写多读少"的环境，避免频繁失败和重试影响性能。

#### 2.4.1 CAS

例子解释：

例子，假如你往地上仍1万块钱，是不是一定会丢呢？这要看情况了，如果是在人来人往的都市，可以说肯定会丢的。如果你跑到无人区扔地上，可以说肯定不会丢。

可以看到，都是把东西无保护的放到公共区域里，结果却相差很大。这说明安全问题还和公共区域的环境状况有关系。

比如我把数据放到公共区域的堆内存中，但是始终都只会有1个线程，也就是单线程模型，那这数据肯定是安全的。

再者说，2个线程操作同一个数据和200个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，线程越少数据不安全的概率越小。取个极限情况，那就是只有1个线程，那不安全概率就是0，也就是安全的。



因为锁的获取和释放是要花费一定代价的，如果在线程数目特别少的时候，可能可能就不会有别的线程来操作数据，此时你还要获取锁和释放锁，可以说是一种浪费。

针对这种"地广人稀"的情况，专门提出了一种方法，叫CAS。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用CAS。

CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：

- V：要更新的变量(var)——内存地址
- E：预期值(expected)——旧值
- N：新值(new)

比较并交换的过程如下：

判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。

我们以一个简单的例子来解释这个过程：

1. 如果有一个多个线程共享的变量`i`原本等于5，我现在在线程A中，想把它设置为新的值6;
2. 我们使用CAS来做这个事情；
3. 首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，`i`的值被设置成了6；
4. 如果不等于5，说明`i`被其它线程改过了（比如现在`i`的值为2），那么我就什么也不做，此次CAS失败，`i`的值仍然为2。

在这个例子中，`i`就是V，5就是E，6就是N。

那有没有可能我在判断了`i`为5之后，正准备更新它的新值的时候，被其它线程更改了`i`的值呢？

不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性。

CAS是一种原子操作，在Java中，有一个`Unsafe`类，它在`sun.misc`包中。它里面是一些`native`方法，其中就有几个关于CAS的，他们都是`public native`的。

**当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。**

**ABA问题？(狸猫换太子)**

因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了，那 CAS 操作就会误认为它从来没有被改变过。

ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A=>B=>A就会变成1A=>2B=>3A。

Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

#### 2.4.2 Atomic（原子操作）

Unsafe类支持CAS的方法。那Java具体是如何使用这几个方法来实现原子操作的呢？

JDK提供了一些用于原子操作的类，在`java.util.concurrent.atomic`包下面。在JDK 8中，有如下17个类：

[![java.util.concurrent.atomic](https://cos.duktig.cn/2021/07/05/1625455891.png)](https://cos.duktig.cn/2021/07/05/1625455891.png)

从名字就可以看得出来这些类大概的用途：

- 原子更新基本类型
- 原子更新数组
- 原子更新引用
- 原子更新字段（属性）

## 3. 总结和分析

**"栈封闭"**：找个只有自己知道的地方藏起来，当然安全了。

**"`ThreadLocal`"**：每人复制1份，各玩各的，互不影响，当然也安全了。

**"不可变"**：更狠了，直接规定，只能读取，禁止修改，当然也安全了。

**互斥同步**和**非阻塞同步**，分别对应**悲观锁**和**乐观锁**的策略。

## 参考

- [CS-Notes——Java并发](https://github.com/CyC2018/CS-Notes)
- [如果你这样回答"什么是线程安全"，面试官都会对你刮目相看](https://zhuanlan.zhihu.com/p/67905621)
- [Java面向对象进阶篇（包装类，不可变类）](https://www.cnblogs.com/yumiaoxia/p/9010721.html)
